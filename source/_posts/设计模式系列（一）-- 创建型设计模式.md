---
title: 设计模式系列（一）-- 创建型设计模式
date: 2018-12-03 10:37:10
tags: [设计模式, 工厂模式, Java]
author: 侯亚东
author_url: https://github.com/hydznsqk
---

# 前言
Android设计模式,共分为三大类,分别是:创建型模式,行为型模式和结构型模式。然后想按照这三个类型去系统的整理分享总结一下,然后本篇分享的是所有的创建型模式。如果想单独看某一个设计模式,可以点击[信仰年輕的设计模式](https://www.jianshu.com/u/f07649312c75)。

<h1 align="center">设计模式（一）-- 简单工厂模式</h1>
<hr>

> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)


## 1.本文目标
本文目标是为了让大家认识并理解简单工厂设计模式。简单工厂模式,它其实不属于GOF23种设计模式,但是在这里也进行一个分享。

## 2.基本套路
定义：由一个工厂对象决定创建出哪一种产品类的实例。

类型：创建型

选择关键点：一种产品是否可根据某个参数决定它的种类。

设计原则：遵循单一职责、违背开闭原则

使用概率：99.99999%

难度系数：低

## 3.适用场景
1.工厂类负责创建的对象比较少。

2.调用者只需要知道传入工厂类的参数,然后如何创建对象并不需要关心。

## 4.使用步骤
1.创建抽象产品类 & 定义具体产品的公共接口；

2.创建具体产品类（继承抽象产品类） & 定义生产的具体产品；

3.创建工厂类，通过创建方法根据传入不同参数从而创建不同具体产品类的实例；

4.外界通过调用工厂类对象的方法，传入不同参数从而创建不同具体产品类的实例

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式
#### 5.1栗子说明
- 背景:想分享,然后通过生产Java视频和Python视频的方式进行传播
- 目的:希望使用简单工厂模式实现这2个产品的生产
#### 5.2使用步骤

实现代码如下:

**步骤1.**创建抽象产品类,定义具体产品的公共接口

```
public abstract class BaseVideo {
    public abstract void produce();
}
```

**步骤2.**创建具体产品类（继承抽象产品类),定义生产的具体产品

```
public class JavaVideo extends BaseVideo {
    @Override
    public void produce() {
        System.out.println("生产JavaVideo");
    }
}
```

```
public class PythonVideo extends BaseVideo {
    @Override
    public void produce() {
        System.out.println("生产PythonVideo");
    }
}
```

**步骤3.**创建工厂类，根据传入不同参数创建不同具体产品类的实例对象

```
public class VideoFactory {

    /**
     * 根据Class字节码对象去得到对应的对象
     */
    public BaseVideo getVideo(Class c){
        BaseVideo video=null;
        try {
            video = (BaseVideo) Class.forName(c.getName()).newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        return video;
    }

    /**
     * 根据type类型去得到对应的对象
     */
    public BaseVideo getVideo(String type){
        if("java".equalsIgnoreCase(type)){
            return new JavaVideo();
        }else if("python".equalsIgnoreCase(type)){
            return new PythonVideo();
        }
        return null;
    }
}
```

**步骤4.** 创建工厂类对象,外界通过调用工厂类对象的方法，传入不同参数从而创建不同具体产品类的实例

```
 public static void main(String[] args) {
        VideoFactory videoFactory = new VideoFactory();

        //创建JavaVideo,根据类的Class字节码
        BaseVideo javaVideo = videoFactory.getVideo(JavaVideo.class);
        javaVideo.produce();

        //创建PythonVideo,根据String字符串类型
        BaseVideo pythonVideo = videoFactory.getVideo("python");
        pythonVideo.produce();
  }
```
## 6.优点
- 只需要传入一个正确的参数,就可以获取你所需要的对象而无需知道其创建细节。

## 7.缺点
- 工厂类的职责相对过重,增加新的产品,需要修改工厂类的判断逻辑,违背开闭原则。



<h1 align="center">设计模式（二）-- 工厂方法模式</h1>
<hr>

> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解工厂方法设计模式。

## 2.基本套路
定义:定义一个创建对象的接口,但是让实现这个接口的类来决定实例化哪个类,工厂方法让类的实例化推迟到子类中进行

类型:创建型

选择关键点:工厂类和产品类是否是同生同灭的关系

设计原则:遵循单一职责、依赖倒置、开闭原则

使用概率:60%

难度系数:低

## 3.适用场景
1.创建对象需要大量重复的代码

2.客户端(应用层)不依赖于产品类实例如何被创建,实现等细节

3.一个类通过其子类来指定创建哪个对象

4.创建对象的过程推迟到子类中来

## 4.使用步骤
1.创建抽象工厂类,定义具体工厂的公共接口

2.创建抽象产品类,定义具体产品的公共接口

3.创建具体产品类(继承抽象产品类)& 定义生产的具体产品

4.创建具体工厂类(继承抽象工厂类),定义创建对应具体产品实例的方法

5.外界通过调用具体工厂类的方法,从而创建不同具体产品类的实例

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1栗子说明
- 背景:想分享,然后通过生产Java视频和Python视频的方式进行传播
- 目的:希望使用工厂方法模式实现这2个产品的生产

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建抽象工厂类,定义具体工厂的公共接口

```
public interface Factory {
    VideoProduct getVideo();
}
```

**步骤2.**创建抽象产品类,定义具体产品的公共接口

```
public abstract class VideoProduct {
    public abstract void produce();
}
```

**步骤3.**创建具体产品类(继承抽象产品类),定义生产的具体产品

```
public class JavaVideo extends VideoProduct {
    @Override
    public void produce() {
        System.out.println("录制Java课程视频");
    }
}
```

```
public class PythonVideo extends VideoProduct {
    @Override
    public void produce() {
        System.out.println("录制Python课程视频");
    }
}
```
**步骤4.** 创建具体工厂类(继承抽象工厂类),定义创建对应具体产品实例的方法

```
public class JavaVideoFactory implements Factory {
    @Override
    public VideoProduct getVideo() {
        return new JavaVideo();
    }
}
```

```
public class PythonVideoFactory implements Factory {
    @Override
    public VideoProduct getVideo() {
        return new PythonVideo();
    }
}
```
**步骤5.** 外界通过调用具体工厂类的方法,从而创建不同具体产品类的实例

```
 public static void main(String[] args) {
        //创建JavaVideo,对应的工厂创建对应的对象
        JavaVideoFactory factory = new JavaVideoFactory();
        BaseVideo video = factory.getVideo();
        video.produce();

        //创建PythonVideo,对应的工厂创建对应的对象
        PythonVideoFactory pythonVideoFactory = new PythonVideoFactory();
        BaseVideo pythonVideo = pythonVideoFactory.getVideo();
        pythonVideo.produce();
  }
```
## 6.优点
- 用户只需要关心所需产品对应的工厂,无需关心创建细节
- 然后类的具体实例化延迟到子类工厂类中去进行
- 加入新产品符合开闭原则,提高可扩展性

## 7.缺点
- 类的个数容易过多,增加复杂度。
- 增加了系统的抽象性和理解难度


<h1 align="center">设计模式（三）-- 抽象工厂模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解抽象工厂设计模式。

## 2.基本套路
定义:提供了一个创建一系列相关或相互依赖对象的接口

类型:创建型

选择关键点:产品族是否需要一起提供,且是否有一致的接口

设计原则:遵循单一职责、依赖倒置、开闭原则

使用概率:30%

难度系数:中

## 3.适用场景
1.客户端(应用层)不依赖于产品实例如何被创建,实现等细节

2.强调一系列相关的产品对象(属于同一产品族)一起使用创建对象需要大量重复的代码

3.提供一个产品类的库,所有的产品以同样的接口出现,从而使客户端不依赖于具体实现

## 4.使用步骤
1.创建抽象工厂接口,定义具体工厂的公共接口

2.创建抽象产品族类,定义抽象产品的公共接口

3.创建具体产品类(继承抽象产品类)& 定义生产的具体产品

4.创建具体工厂类(实现抽象工厂接口),定义创建对应具体产品实例的方法

5.客户端通过实例化具体的工厂类,并调用其创建不同目标产品的方法创建不同具体产品类的实例

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1栗子说明
- 背景:想分享,然后通过生产Java视频和Python视频的方式进行传播
- 目的:希望使用工厂方法模式实现这2个产品的生产

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建抽象工厂接口，定义具体工厂的公共接口

```
public interface BaseCourseFactory {
    BaseVideo getVideo();
    BaseNote getNote();
}
```

**步骤2.**创建抽象产品族类,定义具体产品的公共接口

```
public abstract class BaseNote {
    public abstract void produce();
}
```

```
public abstract class BaseVideo {
    public abstract void produce();
}
```

**步骤3.**创建具体产品类(继承抽象产品类) 定义生产的具体产品

```
public class JavaNote extends BaseNote {
    @Override
    public void produce() {
        System.out.println("编写Java课程笔记");
    }
}
public class JavaVideo extends BaseVideo {
    @Override
    public void produce() {
        System.out.println("生产Java课程视频");
    }
}
```

```
public class PythonNote extends BaseNote {
    @Override
    public void produce() {
        System.out.println("编写Python课程笔记");
    }
}
public class PythonVideo extends BaseVideo {
    @Override
    public void produce() {
        System.out.println("生产Python课程视频");
    }
}
```

**步骤4.** 创建具体工厂类(实现抽象工厂接口),定义创建对应具体产品实例的方法

```
public class JavaCourseFactory implements BaseCourseFactory {

    @Override
    public BaseVideo getVideo() {
        return new JavaVideo();
    }

    @Override
    public BaseNote getNote() {
        return new JavaNote();
    }
}
```

```
public class PythonCourseFactory implements BaseCourseFactory {

    @Override
    public BaseVideo getVideo() {
        return new PythonVideo();
    }

    @Override
    public BaseNote getNote() {
        return new PythonNote();
    }
}
```

**步骤5.** 客户端通过实例化具体的工厂类,并调用其创建不同目标产品的方法创建不同具体产品类的实例

```
 public static void main(String[] args) {
        //通过JavaCourseFactory去创建javaVideo和JavaNote
        BaseCourseFactory courseFactory = new JavaCourseFactory();//创建Java课程工厂
        courseFactory.getVideo().produce();//通过工厂类得到JavaVideo对象并进行创建
        courseFactory.getNote().produce();//通过工厂类得到JavaNote对象并进行创建

        //通过PythonCourseFactory去创建pythonVideo和PythonNote
        PythonCourseFactory pythonCourseFactory = new PythonCourseFactory();//创建Python课程工厂
        pythonCourseFactory.getVideo().produce();//通过工厂类得到PythonVideo对象并进行创建
        pythonCourseFactory.getNote().produce();//通过工厂类得到PythonNote对象并进行创建
  }
```

## 6.优点
- 具体产品在应用层代码隔离,无需关心创建细节
- 将一个系列的产品族统一到一起创建

## 7.缺点
- 规定了所有可能被创建的产品集合,产品族中扩展新的产品困难,需要修改抽象工厂的接口
- 增加了系统的抽象性和理解难度



<h1 align="center">设计模式（四）-- 建造者模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解建造者设计模式。

## 2.基本套路
定义:将一个复杂的对象的构建和它的表示分离,使得同样的构建过程可以创建不同的表示

类型:创建型

选择关键点:各个产品的构建过程是否相同

设计原则:遵循单一职责、开闭原则

使用概率:10%

难度系数:中

## 3.适用场景
1.如果一个对象有非常复杂的内部结构(很多属性字段)

2.想把复杂对象的创建和使用分离。

## 4.使用步骤
1.定义大侠的过程(Builder):定义大侠的名字,年龄和武功

2.构建真正的Person对象并返回

3.Builder属性赋值给Person

4.创建具体的建造者

5.客户端调用-创建武林隐士高手

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式
#### 5.1栗子说明
- 背景:打游戏想创建一个武林大侠
- 目的:希望通过建造者模式去创建

#### 5.2使用步骤
实现代码如下:

```
public class Person {
    private String mName;
    private int mAge;
    private String mKungFu;

    /**
     * 步骤3:Builder属性赋值给Person
     * 构造函数私有化
     * 只让下面的静态方法builder()能够创建对象
     */
    private Person(Builder builder) {
        mName = builder.getName();
        mAge = builder.getAge();
        mKungFu = builder.getKungFu();
    }

    /**
     * 步骤4:创建具体的建造者
     * 构建Person对象的构建器,就是通过Builder这个对象去构建Person对象
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * 步骤1:定义大侠的过程(Builder):定义大侠的名字,年龄和武功
     */
    public static class Builder {

        private String mName;
        private int mAge;
        private String mKungFu;

        public Builder setName(String name) {
            this.mName = name;
            return this;
        }

        public Builder setAge(int age) {
            this.mAge = age;
            return this;
        }

        public Builder setKungFu(String kungfu) {
            this.mKungFu = kungfu;
            return this;
        }

        public String getName() {
            return mName;
        }

        public int getAge() {
            return mAge;
        }

        public String getKungFu() {
            return mKungFu;
        }

        /**
         * 步骤2:构建真正的Person对象并返回
         */
        public Person build() {
            return new Person(this);
        }
    }

    @Override
    public String toString() {
        return "Person{" +
                "mName='" + mName + '\'' +
                ", mAge=" + mAge +
                ", mKungFu='" + mKungFu + '\'' +
                '}';
    }
}

```
测试类:

```
 public static void main(String[] args) {
        Person person = Person.builder()
                .setName("风清扬")
                .setAge(99)
                .setKungFu("独孤九剑")
                .build();
        System.out.println(person.toString());
  }
```

## 6.优点
- 封装性好,创建和使用分离
- 扩展性好,建造类之间独立,一定程度上解耦

## 7.缺点
- 产生多余的Builder对象
- 产品内部发生变化,建造者都要修改,成本比较大

## 8.其他一些思考
建造者模式和工厂模式比较相近,所以二者的区别:

1.建造者模式更注重于方法的调用顺序。

2.工厂模式注重于创建产品。

3.创建对象的力度不同,建造者模式可以创建复杂的产品,由各种复杂的部件组成,工厂模式创建出来的都是一个样子。

4.工厂模式把这个对象创建出来就OK了,但是建造者模式不只是要创建出这个产品,还要知道这个产品由哪些部件组成的。



<h1 align="center">设计模式（五）-- 单例模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理单例设计模式。

## 2.基本套路
定义:保证一个类仅有一个实例,并提供一个全局访问点

类型:创建型

选择关键点:一个对象在应用中出现多个实例是否会引起逻辑上或者是程序上的错误

设计原则:无

使用概率:99.99999%

难度系数:低

## 3.适用场景
1.想确保任何情况下都绝对只有一个实例

## 4.使用步骤
单例模式有多种方式实现,我们一一举例子

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1栗子说明
- 目的:希望全局只有一个对象

#### 5.2饿汉式
实现代码如下:

**步骤1.**构造函数私有化

**步骤2.**创建全局静态final变量

**步骤3.**对外提供一个静态方法

```
public class HungrySingleton implements Serializable{
    //步骤1:构造函数私有化
    private HungrySingleton() {
        //防止反射破解,这一招对饿汉式和静态内部类都好使,对懒汉式不好使
        if(HUNGRYSINGLETON!=null){
            throw new RuntimeException("单例构造器禁止反射调用");
        }
    }

    //步骤2:创建全局静态final变量
    private static final HungrySingleton HUNGRYSINGLETON = new HungrySingleton();

    //步骤3:对外提供一个静态方法
    public static HungrySingleton getInstance() {
        return HUNGRYSINGLETON;
    }

    /**
     * 一旦单例模式涉及到序列化和反序列化,一定要小心单例被破坏掉
     * 这个方法是反射调用的,如果不写这个方法,序列化就会破坏单例(翻看ObjectInputStream源码得知的)
     */
    private Object readResolve(){
        return HUNGRYSINGLETON;
    }
}
```

测试类:

```
 public static void main(String[] args) {
        //正常方式创建对象
        HungrySingleton oldInstance = HungrySingleton.getInstance();

        //反射的方式创建
        Class  objectClass= HungrySingleton.class;
        Constructor constructor =objectClass.getDeclaredConstructor();
        constructor.setAccessible(true);//暴力访问
        HungrySingleton newInstance = (HungrySingleton) constructor.newInstance();

        //比较其地址值
        System.out.println("oldInstance: "+oldInstance);
        System.out.println("newInstance"+newInstance);
        System.out.println(oldInstance==newInstance);
  }
```

#### 5.3静态内部类方式
实现代码如下:

**步骤1.**构造函数私有化

**步骤2.**创建静态内部类对象

**步骤3.**对外提供一个静态方法

```
public class StaticInnerClassSingleton {
    //步骤1:构造函数私有化
    private StaticInnerClassSingleton(){
        //防止反射破解,这一招对饿汉式和静态内部类单例都好使,对懒汉式不好使
        if(Holder.INSTANCE!=null){
            throw new RuntimeException("单例构造器禁止反射调用");
        }
    }

    //步骤3:对外提供一个静态方法
    public static StaticInnerClassSingleton getInstance() {
        return Holder.INSTANCE;
    }

    /**
     * 步骤2:创建静态内部类对象
     * 静态内部类
     */
    private static class Holder {
        private static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();
    }
}
```

测试类:

```
 public static void main(String[] args) {
        StaticInnerClassSingleton single1 = StaticInnerClassSingleton.getInstance();
        StaticInnerClassSingleton single2 = StaticInnerClassSingleton.getInstance();
        //比较其地址值
        System.out.println("single1: "+single1);
        System.out.println("single2"+single2);
        System.out.println(single1==single2);
  }
```

#### 5.4双重校验懒汉式单例
实现代码如下:

**步骤1.**构造函数私有化

**步骤2.**创建全局静态私有变量

**步骤3.**对外提供一个静态方法,里面进行了双重校验

```
public class LazyDoubleCheckSingleton {

    //步骤1:构造函数私有化
    private LazyDoubleCheckSingleton() {
        /**
         * 防止反射破解,这一招对饿汉式和静态内部类都好使,对懒汉式不好使
         * 因为,如果反射的创建方式先进来,就能直接创建对象.
         * 然后正常的创建方式后进来,又能创建对象,就把这个单例破坏了.
         */
        if(mInstance!=null){
            throw new RuntimeException("单例构造器禁止反射调用");
        }
    }

    //步骤2:创建全局静态私有变量
    private static LazyDoubleCheckSingleton mInstance = null;

    //步骤3:对外提供一个静态方法,里面进行了双重校验
    public static LazyDoubleCheckSingleton getInstance() {
        if (mInstance == null) {
            synchronized (LazyDoubleCheckSingleton.class) {
                if (mInstance == null) {
                    mInstance = new LazyDoubleCheckSingleton();
                }
            }
        }
        return mInstance;
    }
}
```
测试类:

```
 public static void main(String[] args) {
        //反射的方式创建
        Class  objectClass= LazyDoubleCheckSingleton.class;
        Constructor constructor =objectClass.getDeclaredConstructor();
        constructor.setAccessible(true);//暴力访问
        LazyDoubleCheckSingleton newInstance = (LazyDoubleCheckSingleton) constructor.newInstance();

        //正常方式创建
        LazyDoubleCheckSingleton oldInstance = LazyDoubleCheckSingleton.getInstance();

        //比较其地址值
        System.out.println("oldInstance: "+oldInstance);
        System.out.println("newInstance"+newInstance);
  }
```

#### 5.5枚举式单例
实现代码如下:

```
public enum EnumInstance {

    INSTANCE;

    private  Object data;

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public static EnumInstance getInstance(){
        return  INSTANCE;
    }
}
```

测试类:

```
 public static void main(String[] args) {
        //正常方式创建
        EnumInstance oldInstance = EnumInstance.getInstance();
        Object newData1 = oldInstance.getData();
        Object newData2 = oldInstance.getData();
        //比较其地址值
        System.out.println("newData1: "+newData1);
        System.out.println("newData2"+newData2);
        System.out.println(newData1==newData2);
  }
```

#### 5.6容器的单例模式
实现代码如下:

```
public class ContainerSingleton {

    private ContainerSingleton() {
    }
    private static Map<String, Object> singletonMap = new HashMap<>();

    public static void putInstance(String key, Object instance) {
        if (!singletonMap.containsKey(key)) {
            singletonMap.put(key, instance);
        }
    }

    public static Object getInstance(String key) {
        return singletonMap.get(key);
    }
}
```

测试类:

```
 public static void main(String[] args) {
        ContainerSingleton.putInstance("city","北京");
        ContainerSingleton.putInstance("风清扬","独孤九剑");

        String str = (String) ContainerSingleton.getInstance("风清扬");
        System.out.println(str);
  }
```


## 6.优点
- 在内存里只有一个实例,减少了内存开销
- 可以避免对资源的多重占用
- 设置了全局访问点,严格控制访问

## 7.缺点
- 没有接口,扩展困难



<h1 align="center">设计模式（六）-- 原型模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解原型模式。

## 2.基本套路
定义:指原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象

类型:创建型

选择关键点:创建出来的对象是否可以立即投入使用

设计原则:无

使用概率:10%

难度系数:中低

## 3.适用场景
1.类初始化消耗较多资源。

2.new产生的一个对象需要非常繁琐的过程(属性赋值,访问权限等)。

3.构造函数比较复杂

4.循环体中生产大量对象

## 4.使用步骤
1.创建具体类实现Cloneable接口

2.重写clone方法

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1浅拷贝栗子说明
- 背景:需要给中奖的同学发送邮件
- 目的:希望使用原型模式生成对象并发送邮件

#### 5.2浅拷贝使用步骤
实现代码如下:

**步骤1.**创建Mail类,实现Cloneable共接口

**步骤2.**重写clone 方法

```
public class Mail implements  Cloneable{

    private String mName;
    private String mEmailAddress;
    private String mContent;

    public Mail() {
        System.out.println("无参构造方法");
    }

    public String getName() {
        return mName;
    }

    public void setName(String mName) {
        this.mName = mName;
    }

    public String getEmailAddress() {
        return mEmailAddress;
    }

    public void setEmailAddress(String mEmailAddress) {
        this.mEmailAddress = mEmailAddress;
    }

    public String getContent() {
        return mContent;
    }

    public void setContent(String mContent) {
        this.mContent = mContent;
    }

    @Override
    public String toString() {
        return "Mail{" +
                "mName='" + mName + '\'' +
                ", mEmailAddress='" + mEmailAddress + '\'' +
                ", mContent='" + mContent + '\'' +
                '}';
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        System.out.println("重写Mail对象的clone方法");
        return super.clone();
    }
}
```
```
public class MailUtil {
    public static void sendMail(Mail mail){
        String outputContent = "向{0}同学,邮件地址:{1},邮件内容:{2}发送邮件成功";
        System.out.println(MessageFormat.format(outputContent,mail.getName(),mail.getEmailAddress(),mail.getContent()));
    }

    public static void saveOriginMailRecord(Mail mail){
        System.out.println("存储originMail记录,originMail:"+mail.getContent());
    }
}
```

测试方法:

```
 public static void main(String[] args) {
        /**
         * 下面这个例子目的是:
         * 创建一个Mail对象,然后保存初始化的内容,然后一个for循环,发送10份出去
         */
        Mail mail = new Mail();
        mail.setContent("初始化模板");
        System.out.println("初始化mail:"+mail);
        for(int i = 0;i < 10;i++){
            //根据原始的Mai对象,去clone 一个全新的Mail对象,这个是用二进制的流的方式复制的,所以性能比较好
            //目前这个是浅拷贝
            Mail mailTemp = (Mail) mail.clone();//这个clone并没有调用构造器,只是调用了clone方法,但是对象是新的

            mailTemp.setName("姓名"+i);
            mailTemp.setEmailAddress("姓名"+i+"@163.com");
            mailTemp.setContent("恭喜您，你中奖了,500W!!!!");

            MailUtil.sendMail(mailTemp);//发送邮件
            System.out.println("克隆的mailTemp:"+mailTemp);
        }
        //假如现在的业务非常复杂,这个保存Mail对象需要放到最后面
        //保存原始的Mail对象
        MailUtil.saveOriginMailRecord(mail);
  }
```

#### 5.3深拷贝使用步骤
实现代码如下:

**步骤1.**创建Pig类,实现Cloneable共接口

**步骤2.**重写clone 方法,在该方法中进行一些操作

```
public class Pig implements Cloneable{
    private String mName;
    private Date mBirthday;

    public Pig(String name, Date birthday) {
        this.mName = name;
        this.mBirthday = birthday;
    }

    public String getName() {
        return mName;
    }

    public void setName(String name) {
        this.mName = name;
    }

    public Date getBirthday() {
        return mBirthday;
    }

    public void setBirthday(Date birthday) {
        this.mBirthday = birthday;
    }

    @Override
    public String toString() {
        return "Pig{" +
                "name='" + mName + '\'' +
                ", birthday=" + mBirthday +
                '}'+super.toString();
    }


    @Override
    public Object clone() throws CloneNotSupportedException {
        //深克隆
        Pig pig = (Pig)super.clone();
        pig.mBirthday = (Date) pig.mBirthday.clone();
        return pig;
    }
}
```

测试方法:

```
 public static void main(String[] args) {
        Date birthday = new Date(0L);
        Pig pig1 = new Pig("佩奇",birthday);
        Pig pig2 = (Pig) pig1.clone();//从pig1 clone出来pig2

        /**
         * 下面的打印pig1和pig2是两个不同的对象,这个没有问题
         * 但是,里面的Date类型的mBirthday生日对象,这个是同一个对象,这个克隆出来的Date引用的是用一个对象
         * 所以修改pig1的生日,pig2也会跟着改变(这就是需要注意的点),所以需要深克隆
         */
        System.out.println(pig1);
        System.out.println(pig2);

        //改变pig1的生日日期,目的只是修改pig1的生日,并没有打算修改pig2的生日
        pig1.getBirthday().setTime(666666666666L);


        /**
         * 如果不在pig对象中的clone方法写下面这一句
         * pig.mBirthday = (Date) pig.mBirthday.clone();
         * 就会出现问题(pig2也跟着改变时间了),所以必须要深克隆,就是加上上面的代码
         */
        System.out.println(pig1);
        System.out.println(pig2);
  }
```

## 6.优点
- 原型模式性能比直接new一个对象性能高
- 简化创建过程

## 7.缺点
- 必须配备克隆方法(这个模式的核心就是clone方法)
- 对克隆复杂对象或对克隆出的对象进行复杂改造时,容易引入风险
- 深拷贝,浅拷贝要运用得当


# 总结
本文只是对所有创建型模式的分享,接下来会继续分享结构型模式和行为型模式,大家可以持续进行关注,[信仰年輕的设计模式](https://www.jianshu.com/u/f07649312c75),蟹蟹啦。




