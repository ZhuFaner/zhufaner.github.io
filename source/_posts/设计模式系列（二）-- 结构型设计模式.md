---
title: 设计模式系列（二）-- 结构型设计模式
date: 2018-12-03 19:37:10
tags: [设计模式, 工厂模式, Java]
author: 侯亚东
author_url: https://github.com/hydznsqk
---

# 前言
Android设计模式,共分为三大类,分别是:创建型模式,行为型模式和结构型模式。接第一篇创建型文章之后的第二篇,本篇分享的是所有的结构型设计模式。如果想单独看某一个设计模式,可以点击[信仰年輕的设计模式](https://www.jianshu.com/u/f07649312c75)。

<h1 align="center">设计模式（七）-- 外观模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解外观模式

## 2.基本套路
定义:又叫门面模式,提供了一个统一的接口,用来访问一个或多个子系统中的一群接口

类型:结构型

选择关键点:子系统对外提供服务是否需要依赖很多的类

设计原则:遵循迪米特

使用概率:60%

难度系数:中

## 3.适用场景
1.子系统越来越复杂,增加外观模式提供简单调用接口

2.构建多层结构,利用外观对象作为每层的入口,简化层间调用

## 4.使用步骤
用具体的栗子更容易说明问题,继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1栗子说明
- 背景:某电商平台上面有积分可以换小礼物
- 目的:兑换礼物需要走好几个系统(资格兑换子系统,积分支付子系统,物流服务子系统),希望使用外观模式统一管理

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建积分礼物类

```
public class PointGift {
    private String name;
    public PointGift(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
}
```

**步骤2.**创建资格兑换子系统

```
public class QualifyService {
    public boolean isAvailable(PointGift pointsGift){
        System.out.println("校验"+pointsGift.getName()+" 积分资格通过,库存通过");
        return true;
    }
}
```

**步骤3.**创建积分支付子系统

```
public class PointsPaymentService {
    public boolean pay(PointGift pointsGift) {
        //扣减积分
        System.out.println("支付" + pointsGift.getName() + " 积分成功");
        return true;
    }
}
```

**步骤4.** 创建物流服务子系统

```
public class LogisticsService {
    public String shipGift(PointGift pointsGift){
        //物流系统的对接逻辑
        System.out.println(pointsGift.getName()+"进入物流系统");
        String logisticsOrderNo = "666";//物流订单ID
        return logisticsOrderNo;
    }
}
```

**步骤5.** 创建外观类,统一管理上面的3个子系统

```
public class GiftExchangeService {
    private QualifyService mQualifyService = new QualifyService();//资格兑换子系统
    private PointsPaymentService mPointsPaymentService = new PointsPaymentService();//积分支付子系统
    private LogisticsService mLogisticsService = new LogisticsService();//物流子系统

    public void giftExchange(PointGift pointsGift){
        if(mQualifyService.isAvailable(pointsGift)){
            //资格校验通过
            if(mPointsPaymentService.pay(pointsGift)){
                //如果支付积分成功
                String shippingOrderNo = mLogisticsService.shipGift(pointsGift);
                System.out.println("物流系统下单成功,订单号是:"+shippingOrderNo);
            }
        }
    }
}
```

**步骤6.** 测试

```
 public static void main(String[] args) {
        PointGift pointsGift = new PointGift("鼠标");
        GiftExchangeService giftExchangeService = new GiftExchangeService();
        giftExchangeService.giftExchange(pointsGift);
  }
```
#### 5.3代码总结思考
就是说兑换这个小礼物需要走3个子系统,然后我们提供一个外观类对象(GiftExchangeService),提供统一的入口,让外观类(GiftExchangeService)去和3个子系统通信,然后我们的应用层(也就是FacadeTest这个类)只需要和外观类通信就完了,应用层(TestFacade)<=>外观类(GiftExchangeService)<=>3个子系统(QualifyService,PointsPaymentService,LogisticsService)

## 6.优点
- 简化了调用过程,无需了解深入子系统,防止带来风险
- 减少系统依赖,松散耦合(客户端不和子系统直接交流,而是通过外观模式进行交流)
- 更好的划分访问层次
- 符合迪米特法则,即最少知道原则(客户端不需要了解子系统内部的实现,只需要和外观类交互就完了)

## 7.缺点
- 增加子系统,扩展子系统行为容易引入风险
- 不符合开闭原则


<h1 align="center">设计模式（八）-- 装饰器模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解装饰器模式

## 2.基本套路
定义:在不改变原有对象的基础之上,将功能附加到对象上

类型:结构型

选择关键点:添加的功能是否需要动态组装

设计原则:遵循迪米特、单一职责、开闭原则，破坏里氏替换，体现功能复用

使用概率:99.99999%

难度系数:中

## 3.适用场景
1.扩展一个类的功能或给一个类添加附加职责

2.动态的给一个对象添加功能,这些功能可以再动态的撤销

## 4.使用步骤
用具体的栗子更容易说明问题,继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1栗子说明
- 背景:公司的小伙伴小王饿了,想买个煎饼
- 目的:不仅仅是吃个煎饼,他还想加蛋,加烤肠,希望用装饰器模式实现

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建抽象的实体类(抽象的煎饼)

```
public abstract class ABatterCake {
    public abstract String getDesc();
    public abstract int cost();
}
```

**步骤2.**创建具体的实体类(具体的煎饼)继承抽象的实体类

```
public class BatterCake extends  ABatterCake {
    @Override
    public String getDesc() {
        return "煎饼";
    }

    @Override
    public int cost() {
        return 8;
    }
}
```

**步骤3.**创建抽象的装饰类,继承抽象的实体类(抽象的煎饼)

```
public class AbstractDecorator  extends ABatterCake{
    private ABatterCake mBatterCake;//抽象的煎饼,当然也可以传具体的煎饼
    public AbstractDecorator(ABatterCake mBatterCake) {
        this.mBatterCake = mBatterCake;
    }
    @Override
    public String getDesc() {
        return this.mBatterCake.getDesc();
    }

    @Override
    public int cost() {
        return this.mBatterCake.cost();
    }
}
```
**步骤4.** 创建具体的装饰类(鸡蛋装饰类),继承抽象的装饰类

```
public class EggDecorator extends AbstractDecorator {

    public EggDecorator(ABatterCake mBatterCake) {
        super(mBatterCake);
    }

    @Override
    public String getDesc() {
        return super.getDesc()+"加一个鸡蛋";
    }

    @Override
    public int cost() {
        return super.cost()+1;
    }
}
```

**步骤5.** 创建具体的装饰类(烤肠装饰类),继承抽象的装饰类

```
public class SausageDecorator extends AbstractDecorator {
    public SausageDecorator(ABatterCake mBatterCake) {
        super(mBatterCake);
    }

    @Override
    public String getDesc() {
        return super.getDesc()+"加一个烤肠";
    }

    @Override
    public int cost() {
        return super.cost()+2;
    }
}
```
**步骤6.** 测试

```
 public static void main(String[] args) {
        ABatterCake batterCake;
        //煎饼
        batterCake = new com.yadong.pattern.structural.decorator.v2.BatterCake();
        //加蛋
        batterCake = new EggDecorator(batterCake);
        //在加蛋
        batterCake = new EggDecorator(batterCake);
        //加个烤肠
        batterCake = new SausageDecorator(batterCake);
        /**
         * 输出结果:
         * 8+1+1+2=12块钱
         * 煎饼加一个鸡蛋加一个鸡蛋加一个烤肠 销售价格:12
         */
        System.out.println(batterCake.getDesc()+" 销售价格:"+batterCake.cost());


        /**
         * 另外一种写法,连起来写
         * 输出结果:
         * 煎饼加一个鸡蛋加一个烤肠加一个烤肠 销售价格:13
         * 煎饼+蛋+烤肠+烤肠
         * 8+1+2+2=13块钱
         */
        SausageDecorator sausageBatterCake= new SausageDecorator(new SausageDecorator(new EggDecorator(new BatterCake())));
        System.out.println(sausageBatterCake.getDesc()+" 销售价格:"+sausageBatterCake.cost());
  }
```

## 6.优点
- 继承的有力补充,比继承灵活,不改变原有对象的情况下给一个对象扩展功能
- 通过使用不同装饰类以及这些装饰类的排列组合,可以实现不同效果
- 符合开闭原则

## 7.缺点
- 会出现更多的代码,更多的类,增加程序复杂性
- 动态装饰时,多层装饰会更复杂



<h1 align="center">设计模式（九）-- 适配器模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解适配器模式

## 2.基本套路
定义:将一个类的接口转换成客户期望的另一个接口

类型:结构型

选择关键点:定制适配器的选择关键点在于是否有更加优良的替代方案，缺省适配器的选择关键点在于接口中的方法是否可以不全部提供，且都有缺省方案

设计原则:遵循开闭原则、体现功能复用

使用概率:40%

难度系数:中

## 3.适用场景
1.已经存在的类,它的方法和需求不匹配时(方法结果相同或相似)

2.不是软件设计阶段考虑的设计模式,是随着软件维护,由于不同产品,不同厂家造成功能类似而接口不相同情况下的解决方案

## 4.使用步骤
1.需要4个角色,被适配者,适配者,目标接口,目标接口的实现类(这个实现类可以有也可以没有,看具体业务)

2.目的就是让适配者通过他的一顿操作,达到融合被适配者和目标接口到一个类中

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1栗子说明
- 背景:把220V的电压通过手机充电器转换成5V的电压给手机进行充电
- 目的:通过适配器模式去进行一个转换

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建被适配者(220V的电压类)

```
public class AC220 {
    public int outputAC220V(){
        int output = 220;
        System.out.println("输出交流电"+output+"V");
        return output;
    }
}
```

**步骤2.**创建目标接口(DC5)

```
public interface DC5 {
    int outputDC5V();
}
```

**步骤3.**创建适配器(PowerAdapter)

```
public class PowerAdapter implements DC5 {

    private AC220 ac220=new AC220();

    @Override
    public int outputDC5V() {
        int adapterInput = ac220.outputAC220V();

        //模拟变压器
        int adapterOutput = adapterInput/44;

        System.out.println("使用PowerAdapter输入AC:"+adapterInput+"V"+"输出DC:"+adapterOutput+"V");
        return adapterOutput;
    }
}
```

**步骤4.** 测试

```
 public static void main(String[] args) {
        DC5 dc5 = new PowerAdapter();
        dc5.outputDC5V();
 }
```

## 6.优点
- 能提高类的透明性和复用,现有的类复用但不需要改变
- 目标类和适配器类解耦,提高程序扩展性
- 符合开闭原则

## 7.缺点
- 适配器编写过程要全面考虑,可能会增加系统的复杂性
- 增加系统代码可读的难度



<h1 align="center">设计模式（十）-- 享元模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解享元模式

## 2.基本套路
定义:提供了减少对象数量从而改善应用所需的对象结构的方式

类型:结构型

选择关键点:被共享的对象是否可以将外部状态提取出来

设计原则:无

使用概率:90%

难度系数:中

## 3.适用场景
1.常常应用于系统底层的开发,以便解决系统的性能问题

2.系统有大量相似对象,需要缓冲池的场景

## 4.使用步骤
用具体的栗子可以更好的理解,继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1栗子说明
- 背景:年底了,各个部门经理需要做报告
- 目的:用享元模式去进行设计代码

#### 5.2使用步骤

实现代码如下:

**步骤1.**创建员工接口

```
public interface Employee {
    void report();
}
```

**步骤2.**创建部门经理,经理本身也属于员工

```
public class Manager implements Employee {

    private String department;//所属部门
    private String reportContent;//报告内容

    public Manager(String department) {
        this.department = department;
    }

    @Override
    public void report() {
        System.out.println(reportContent);
    }
    /**
     * 设置报告内容
     */
    public void setReportContent(String reportContent) {
        this.reportContent = reportContent;
    }
}
```

**步骤3.**创建员工工厂,精髓就在这一步,如果没有对象就创建,有的话就存储到Map集合中

```
public class EmployeeFactory {
    private static final Map<String,Employee> EMPLOYEE_MAP = new HashMap<>();
    /**
     * 根据部门去获取部门经理
     */
    public static Employee getManager(String department){
        Manager manager = (Manager) EMPLOYEE_MAP.get(department);

        if(manager == null){
            manager = new Manager(department);
            System.out.print("创建部门经理:"+department);

            String reportContent = department+"部门汇报:此次报告的主要内容是......";
            manager.setReportContent(reportContent);
            System.out.println(" 创建报告:"+reportContent);

            //存到map集合中
            EMPLOYEE_MAP.put(department,manager);
        }
        return manager;
    }
}

```
**步骤4.** 测试

```
 public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            String department = departments[(int) (Math.random() * departments.length)];
            Manager manager = (Manager) EmployeeFactory.getManager(department);
            manager.report();
        }
 }
```

## 6.优点
- 减少对象的创建,降低内存中对象的数量,降低系统的内存,提高效率
- 减少内存之外的其他资源占用

## 7.缺点
- 关注内/外部状态,关注线程安全问题
- 使系统,程序的逻辑复杂化



<h1 align="center">设计模式（十一）-- 组合模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解组合模式

## 2.基本套路
定义:将对象组合成树形结构以表示【部分-整体】的层次结构

类型:结构型

选择关键点:被共享的对象是否可以将外部状态提取出来

设计原则:无

使用概率:90%

难度系数:中

## 3.适用场景
1.希望客户端可以忽略组合对象与单个对象的差异时

2.处理一个树形结构时

## 4.使用步骤
用具体的栗子可以更好的理解,继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1栗子说明
- 背景:有很多课程,然后也有很多目录,需要把这些课程进行树桩结构分类
- 目的:用组合模式去进行这些课程和目录的实现

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建目录抽象类

```
public abstract class CatalogComponent {
    public void add(CatalogComponent catalogComponent) {
        throw new UnsupportedOperationException("不支持添加操作");
    }

    public void remove(CatalogComponent catalogComponent) {
        throw new UnsupportedOperationException("不支持删除操作");
    }

    public String getName(CatalogComponent catalogComponent) {
        throw new UnsupportedOperationException("不支持获取名称操作");
    }

    public double getPrice(CatalogComponent catalogComponent) {
        throw new UnsupportedOperationException("不支持获取价格操作");
    }

    public void print() {
        throw new UnsupportedOperationException("不支持打印操作");
    }
}
```

**步骤2.**创建课程,继承于目录抽象类

```
public class Course extends CatalogComponent {
    private String name;
    private double price;

    public Course(String name, double price) {
        this.name = name;
        this.price = price;
    }

    @Override
    public String getName(CatalogComponent catalogComponent) {
        return this.name;
    }

    @Override
    public double getPrice(CatalogComponent catalogComponent) {
        return this.price;
    }

    @Override
    public void print() {
        System.out.println("Course Name:" + name + " Price:" + price);
    }
}
```

**步骤3.**创建目录,继承于目录抽象类

```
public class CourseCatalog extends CatalogComponent {
    private List<CatalogComponent> items = new ArrayList<>();
    private String name;
    private Integer level;

    public CourseCatalog(String name, Integer level) {
        this.name = name;
        this.level = level;
    }

    @Override
    public void add(CatalogComponent catalogComponent) {
        items.add(catalogComponent);
    }

    @Override
    public String getName(CatalogComponent catalogComponent) {
        return this.name;
    }

    @Override
    public void remove(CatalogComponent catalogComponent) {
        items.remove(catalogComponent);
    }

    @Override
    public void print() {
        System.out.println(this.name);
        for (CatalogComponent catalogComponent : items) {
            if (this.level != null) {
                for (int i = 0; i < this.level; i++) {
                    System.out.print("  ");
                }
            }
            catalogComponent.print();
        }
    }
}
```

**步骤4.** 测试,1级目录是课程主目录,2级目录分别是Java课程目录,操作系统课程目录

```
 public static void main(String[] args) {
        //二级目录
        CatalogComponent operatingSystem = new CourseCatalog("操作系统课程目录",2);
        CatalogComponent linuxCourse = new Course("Linux课程",100);
        CatalogComponent windowsCourse = new Course("Windows课程",120);
        operatingSystem.add(linuxCourse);
        operatingSystem.add(windowsCourse);

        //二级目录
        CatalogComponent javaCourseCatalog = new CourseCatalog("Java课程目录",2);
        CatalogComponent javaBase = new Course("Java基础",66);
        CatalogComponent designPattern = new Course("Java设计模式",77);
        javaCourseCatalog.add(javaBase);
        javaCourseCatalog.add(designPattern);

        //一级目录(主目录)
        CatalogComponent mainCourseCatalog = new CourseCatalog("课程主目录",1);
        mainCourseCatalog.add(linuxCourse);
        mainCourseCatalog.add(windowsCourse);
        mainCourseCatalog.add(javaCourseCatalog);
        mainCourseCatalog.print();
 }
```

## 6.优点
- 清楚的定义分层次的复杂对象,表示对象的全部或部分层次
- 让客户端忽略了层次的差异,方便对整个层次结构进行控制
- 简化客户端的代码
- 符合开闭原则

## 7.缺点
- 限制类型时会较为复杂
- 使设计变的更加抽象


<h1 align="center">设计模式（十二）-- 桥接模式</h1>
<hr>

> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解桥接模式

## 2.基本套路
定义:将抽象部分与它的具体实现部分分离,使它们都可以独立地变换

类型:结构型

选择关键点:是否可以将对象拆分成多个不相关的维度

设计原则:遵循单一职责、迪米特、开闭原则，体现功能复用

使用概率:20%

难度系数:中高

## 3.适用场景
1.抽象和具体之间增加更多的灵活性

2.一个类存在两个(或多个)独立变化的维度,且这两个(或多个)维度都需要独立进行扩展

3.不希望使用继承,或因为多层继承导致系统类的个数剧增

## 4.使用步骤
用具体的栗子可以更好的理解,继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1栗子说明
- 背景:中国有很多银行,有农业银行和工商银行,有自己的账号,然后分为定期和活期,我们想一下,一块是银行,一块是账号
- 目的:以后银行会越来越多,希望用桥接模式去进行设计,便于扩展

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建银行账号接口类

```
public interface Account {
    //打开账号
    Account openAccount();

    //查看账号的类型(是活期还是定期)
    void showAccountType();
}
```

**步骤2.** 创建定期账号和活期账号,实现于Account接口

```
//定期账号
public class DepositAccount implements Account {
    @Override
    public Account openAccount() {
        System.out.println("打开定期账号");
        return new DepositAccount();
    }

    @Override
    public void showAccountType() {
        System.out.println("这是一个定期账号");
    }
}

//活期账号
public class SavingAccount implements Account {
    @Override
    public Account openAccount() {
        System.out.println("打开活期账号");
        //...
        return new SavingAccount();
    }

    @Override
    public void showAccountType() {
        System.out.println("这是一个活期账号");
    }
}
```
**步骤3.**创建银行抽象类,桥在这个类中

```
public abstract class Bank {
    //通过组合的方式建立两个类的连线,桥在这里
    protected Account account;
    public Bank(Account account) {
        this.account = account;
    }
    abstract Account openAccount();
}

```

**步骤4.**创建中国工商银行和中国农业银行,继承于Bank

```
//工商银行
public class ICBCBank extends Bank {
    public ICBCBank(Account account) {
        super(account);
    }

    @Override
    Account openAccount() {
        System.out.println("打开中国工商银行账号");
        account.openAccount();
        return account;
    }
}

//农业银行
public class ABCBank extends Bank {
    public ABCBank(Account account) {
        super(account);
    }

    @Override
    Account openAccount() {
        System.out.println("打开中国农业银行账号");
        account.openAccount();
        return account;
    }
}
```
**步骤5.** 测试

```
 public static void main(String[] args) {
        //工商银行,然后账号类型是 定期
        Bank icbcBank = new ICBCBank(new DepositAccount());
        Account icbcAccount = icbcBank.openAccount();
        icbcAccount.showAccountType();

        //工商银行,然后账号类型是 活期
        Bank icbcBank2 = new ICBCBank(new SavingAccount());
        Account icbcAccount2 = icbcBank2.openAccount();
        icbcAccount2.showAccountType();

        //农业银行,然后账号类型是 活期
        Bank abcBank = new ABCBank(new SavingAccount());
        Account abcAccount = abcBank.openAccount();
        abcAccount.showAccountType();
 }
```
## 6.优点
- 分离抽象部分和具体实现部分
- 提高了系统的可扩展性
- 符合开闭原则
- 符合合成复用原则

## 7.缺点
- 增加了系统的理解和设计难度
- 需要正确的识别出系统中两个独立变化的维度


<h1 align="center">设计模式（十三）-- 代理模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解代理模式

## 2.基本套路
定义:为其他对象提供一种代理,以控制对这个对象的访问

类型:结构型

选择关键点:静态代理选择的关键点是是否要复用被代理的部分功能，动态代理选择的关键点在于能否在将被代理的这一批类当中，找出相同的切入点

设计原则:体现功能复用

使用概率:99.99999%

难度系数:中高

## 3.适用场景
1.保护目标对象

2.增强目标对象

## 4.使用步骤
1.代理模式有委托方和代理方

2.委托方定义接口和使用接口中的方法

3.代理方把代理对象传给委托方并实现委托方的接口,从而实现代理模式

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1栗子说明
- 背景:现在有一个 添加页面,联系人页面,当在添加页面中添加数据的时候,要把数据传递到联系人页面显示
- 目的:通过代理模式实现传递数据

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建委托方要定义接口(就是DataInterface)

```
public interface DataInterface {
    /**
     * 添加数据的方法
     */
    void  addData(AddController controller, String name);
}
```

**步骤2.**创建委托方,委托方使用接口中的方法

```
public class AddController {
    //定义接口
    public DataInterface mDataInterface;
    public void  addEvent(){
        //使用接口中的方法
        mDataInterface.addData(this,"黄晓明");
    }
}
```

**步骤3.**创建代理方,实现接口

```
public class ContactController implements  DataInterface{
    @Override
    public void addData(AddController page, String name) {
        System.out.println("ContactController 添加数据成功 "+page.toString()+ "  名字:"+ name);
    }
}
```

**步骤4.** 测试,代理方把代理对象传给委托方并实现委托方的接口,从而实现代理模式

```
 public static void main(String[] args) {
        AddController addController = new AddController();
        ContactController contactController = new ContactController();

        //代理方把代理对象传给委托方
        addController.mDataInterface = contactController;
        addController.addEvent();
 }
```

## 6.优点
- 代理模式能将代理对象与真实被调用的目标对象分离
- 一定程度上降低了系统的耦合度,扩展性好
- 保护目标对象
- 增强目标对象

## 7.缺点
- 代理模式会早场系统设计中类的数目增加
- 在客户端和目标对象增加一个代理对象,会造成请求处理速度变慢
- 增加系统的复杂度

# 总结
本文只是对所有结构型模式的分享,接下来会继续分享行为型模式,大家可以持续进行关注,[信仰年輕的设计模式](https://www.jianshu.com/u/f07649312c75),蟹蟹啦。





