title: 设计模式系列（三）-- 行为型设计模式
tags:
  - 设计模式
  - Android
  - 工厂模式
  - Java
author: 侯亚东
author_url: 'https://github.com/hydznsqk'
date: 2018-12-05 17:37:10
---

#前言
Android设计模式,共分为三大类,分别是:创建型模式,行为型模式和结构型模式。接第二篇结构型文章之后的第三篇,本篇分享的是所有的行为型设计模式。如果想单独看某一个设计模式,可以点击[信仰年輕的设计模式](https://www.jianshu.com/u/f07649312c75)。

<h1 align="center">设计模式（十四）-- 模板方法模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解模板方法模式

## 2.基本套路
定义:定义了一个算法的骨架,并允许子类为一个或多个步骤提供实现

类型:行为型

选择关键点:算法骨架是否牢固

设计原则:破坏里氏替换，体现功能复用

使用概率:80%

难度系数:中低

## 3.适用场景
1.一次性实现一个算法的不变的部分,并将可变的行为留给子类来实现

2.各子类中公共的行为被提取出来并集中到一个公共父类中,从而避免代码重复

## 4.使用步骤
用栗子能更好的说明问题,请继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式
#### 5.1栗子说明
- 背景:录制视频都需要编写ppt,制作视频和写手记,然后用这个模板制作不同的课程
- 目的:通过模板方法去制作

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建课程抽象类

```java
public abstract class ACourse {

    //模板方法 制作课程
    protected final void makeCourse(){
        this.makePPT();
        this.makeVideo();
        if(needWriteArticle()){
            this.writeArticle();
        }
        this.packageCourse();
    }

    final void makePPT(){
        System.out.println("制作PPT");
    }
    final void makeVideo(){
        System.out.println("制作视频");
    }
    final void writeArticle(){
        System.out.println("编写手记");
    }
    //钩子方法
    protected boolean needWriteArticle(){
        return false;
    }
    
    //包装课程
    abstract void packageCourse();
}
```
**步骤2.**创建设计模式课程,继承抽象课程类

```java
public class DesignPatternCourse extends ACourse {
    @Override
    void packageCourse() {
        System.out.println("提供课程Java源代码");
    }

    @Override
    protected boolean needWriteArticle() {
        return true;
    }
}
```

**步骤3.**创建前端课程,继承抽象课程类

```java
public class FECourse extends ACourse {

    private boolean needWriteArticleFlag = false;

    @Override
    void packageCourse() {
        System.out.println("提供课程的前端代码");
        System.out.println("提供课程的图片等多媒体素材");
    }

    public FECourse(boolean needWriteArticleFlag) {
        this.needWriteArticleFlag = needWriteArticleFlag;
    }

    @Override
    protected boolean needWriteArticle() {
        return this.needWriteArticleFlag;
    }
}
```

**步骤4.** 测试

```java
 public static void main(String[] args) {
        System.out.println("设计模式课程start---");
        ACourse designPatternCourse = new DesignPatternCourse();
        designPatternCourse.makeCourse();
        System.out.println("设计模式课程end---");


        System.out.println("前端课程start---");
        ACourse feCourse = new FECourse(false);
        feCourse.makeCourse();
        System.out.println("前端课程end---");
 }
```

## 6.优点
- 提高复用性
- 提高扩展性
- 符合开闭原则

## 7.缺点
- 类数目的增加
- 增加了系统实现的复杂度
- 继承关系自身缺点,如果父类添加新的抽象方法,所有的子类都要改一遍


<h1 align="center">设计模式（十五）-- 迭代器模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解迭代器模式

## 2.基本套路
定义:提供一种方法,顺序访问一个集合对象中的各个元素,而又不暴露该对象的内部表示

类型:行为型

选择关键点:客户端是否关心遍历的次序

设计原则:遵循迪米特

使用概率:99.99999%

难度系数:中

## 3.适用场景
1.访问一个集合对象的内容而无需暴露它的内部表示

2.为遍历不同的集合结构提供一个统一的接口

## 4.使用步骤
用栗子能更好的说明问题,请继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式
#### 5.1栗子说明
- 背景:网上有很多学习Java的课程
- 目的:然后想通过迭代器模式去进行遍历并打印

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建课程的实体类

```java
public class Course {
    private String name;

    public Course(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```
**步骤2.**创建课程的集合 接口

```java
public interface CourseAggregate {

    /**
     * 添加课程
     */
    void addCourse(Course course);

    /**
     * 删除课程
     */
    void removeCourse(Course course);

    /**
     * 课程迭代器
     */
    CourseIterator getCourseIterator();
}
```

**步骤3.**创建课程的集合 的实现类

```java
public class CourseAggregateImpl implements CourseAggregate {

    private List courseList;

    public CourseAggregateImpl() {
        this.courseList = new ArrayList();
    }

    @Override
    public void addCourse(Course course) {
        courseList.add(course);
    }

    @Override
    public void removeCourse(Course course) {
        courseList.remove(course);
    }

    @Override
    public CourseIterator getCourseIterator() {
        return new CourseIteratorImpl(courseList);
    }
}
```

**步骤4.** 课程迭代器的接口类

```java
public interface CourseIterator {
    /**
     * 获取下个一个课程
     */
    Course nextCourse();

    /**
     * 是不是下一个课程
     */
    boolean isLastCourse();
}
```

**步骤5.** 课程迭代器的实现类

```java
public class CourseIteratorImpl implements CourseIterator {
    private List courseList;
    private int position;
    private Course course;
    public CourseIteratorImpl(List courseList){
        this.courseList=courseList;
    }

    @Override
    public Course nextCourse() {
        System.out.println("返回课程,位置是: "+position);
        course=(Course)courseList.get(position);
        position++;
        return course;
    }

    @Override
    public boolean isLastCourse(){
        if(position< courseList.size()){
            return false;
        }
        return true;
    }
}
```

**步骤6.** 测试

```java
 public static void main(String[] args) {
         //创建3个课程
        Course course1 = new Course("Java基础");
        Course course2 = new Course("Android基础");
        Course course3 = new Course("Java设计模式");

        //把这3个课程添加到课程集合类中
        CourseAggregate courseAggregate = new CourseAggregateImpl();
        courseAggregate.addCourse(course1);
        courseAggregate.addCourse(course2);
        courseAggregate.addCourse(course3);

        System.out.println("-----课程列表-----");
        printCourses(courseAggregate);
        //删除课程3(Java设计模式)
        courseAggregate.removeCourse(course3);
        System.out.println("-----删除操作之后的课程列表-----");
        printCourses(courseAggregate);
 }

  /**
   * 遍历迭代器并打印课程的名字
   */
  public static void printCourses(CourseAggregate courseAggregate){
        CourseIterator courseIterator= courseAggregate.getCourseIterator();
        while(!courseIterator.isLastCourse()){
            Course course=courseIterator.nextCourse();
            System.out.println(course.getName());
       }
  }
```

## 6.优点
- 分离了集合对象的遍历行为


## 7.缺点
- 类的个数成对增加


<h1 align="center">设计模式（十六）-- 策略模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解策略模式

## 2.基本套路
定义:定义了算法家族,分别封装起来,让它们之间可以互相替换,此模式让算法的变化不会影响到使用算法的用户

类型:行为型

选择关键点:客户端是否依赖于某一个或若干个具体的策略

设计原则:遵循单一职责、依赖倒置、迪米特、开闭原则

使用概率:60%

难度系数:中

## 3.适用场景
1.系统有很多类,而它们的区别仅仅在于它们的行为不同

2.一个系统需要动态的在几种算法中选择一种

## 4.使用步骤
用栗子能更好的说明问题,请继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式
#### 5.1栗子说明
- 背景:鸭子有很多种类,然后有能飞的和不能飞的
- 目的:用策略模式实现鸭子的行为

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建飞行的行为接口

```java
public interface FlyBehaviour {
    void fly();
}
```
**步骤2.**创建能够飞行的行为接口实现类

```java
public class FlyImp implements FlyBehaviour {
    @Override
    public void fly() {
        System.out.println("能够飞行~~~");
    }
}
```

**步骤3.**创建不能够飞行的行为接口实现类

```java
public class FlyNoWayImp implements FlyBehaviour {
    @Override
    public void fly() {
        System.out.println("不能飞,飞不起来~~~");
    }
}
```

**步骤4.** 创建父类 Duck

```java
public abstract class BaseDuck {

    //这个是接口,让子类去实现这个接口
    FlyBehaviour mFlyBehaviour;

    public void fly() {
        mFlyBehaviour.fly();
    }

    public abstract void display();

    /**
     * 设置可以飞行的行为接口实现类
     */
    public void  setFlyBehaviour(FlyImp flyImp){
        this.mFlyBehaviour=flyImp;
    }

    /**
     * 设置不可以飞行的行为接口实现类
     */
    public  void  setFlyNoWayBehaviour(FlyNoWayImp flyNoWayBehaviour){
        this.mFlyBehaviour=flyNoWayBehaviour;

    }
}
```

**步骤5.** 创建北京烤鸭,飞不起来

```java
public class BeiJingDuck extends BaseDuck {

    public BeiJingDuck() {
        mFlyBehaviour = new FlyNoWayImp();
    }

    @Override
    public void display() {
        System.out.println(BeiJingDuck.class.getName());
    }
}
```

**步骤6.** 创建绿头鸭,能够飞行

```java
public class GreenHeadDuck extends BaseDuck {
    public GreenHeadDuck() {
        this.mFlyBehaviour = new FlyImp();
    }

    @Override
    public void display() {
        System.out.println(GreenHeadDuck.class.getName());
    }
}
```

**步骤7.** 测试,上面的一系列操作就是分别封装行为接口,实现算法族,父类中放行为接口对象,在子类里具体设定行为对象

```java
 public static void main(String[] args) {
        BaseDuck beiJingDuck = new BeiJingDuck();
        BaseDuck greenHeadDuck = new GreenHeadDuck();
        beiJingDuck.display();
        greenHeadDuck.fly();
        beiJingDuck.display();
        greenHeadDuck.fly();
 }
```

## 6.优点
- 开闭原则
- 避免使用多重条件转移语句
- 提高算法的保密性和安全性


## 7.缺点
- 客户端必须知道所有的策略类,并自行决定使用哪一个策略类
- 产生很多策略类



<h1 align="center">设计模式（十七）-- 解释器模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解解释器模式

## 2.基本套路
定义:给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语言中的句子

类型:行为型

选择关键点:被频繁使用的语言是否可用文法表示

设计原则:遵循单一职责

使用概率:0.00009%

难度系数:中

## 3.适用场景
1.某个特定类型问题发生频率足够高

## 4.使用步骤
用栗子能更好的说明问题,请继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式
#### 5.1栗子说明
- 背景:输入一个字符串,通过自定义解释器,去得到一个结果
- 目的:用解释器模式自定义

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建解释器接口

```java
public interface Interpreter {
    int interpret();
}
```
**步骤2.**创建加法解释器 实现解释器接口

```java
public class AddInterpreter implements Interpreter {
    private Interpreter firstExpression, secondExpression;

    public AddInterpreter(Interpreter firstExpression, Interpreter secondExpression) {
        this.firstExpression = firstExpression;
        this.secondExpression = secondExpression;
    }

    @Override
    public int interpret() {
        return this.firstExpression.interpret() + this.secondExpression.interpret();
    }

    @Override
    public String toString() {
        return "+";
    }
}
```

**步骤3.**创建乘法解释器 实现解释器接口

```java
public class MultiInterpreter implements Interpreter {

    private Interpreter firstExpression,secondExpression;
    public MultiInterpreter(Interpreter firstExpression, Interpreter secondExpression){
        this.firstExpression=firstExpression;
        this.secondExpression=secondExpression;
    }
    @Override
    public int interpret(){
        return this.firstExpression.interpret()*this.secondExpression.interpret();
    }
    @Override
    public String toString(){
        return "*";
    }
}
```

**步骤4.** 创建数字解释器 实现解释器接口

```java
public class NumberInterpreter implements Interpreter {
    private int number;

    public NumberInterpreter(int number) {
        this.number = number;
    }

    public NumberInterpreter(String number) {
        this.number = Integer.parseInt(number);
    }

    @Override
    public int interpret() {
        return this.number;
    }
}
```

**步骤5.** 创建工具类

```java
public class OperatorUtil {
    public static boolean isOperator(String symbol) {
        return (symbol.equals("+") || symbol.equals("*"));
    }

    public static Interpreter getExpressionObject(Interpreter firstExpression, Interpreter secondExpression, String symbol) {
        if (symbol.equals("+")) {
            return new AddInterpreter(firstExpression, secondExpression);
        } else if (symbol.equals("*")) {
            return new MultiInterpreter(firstExpression, secondExpression);
        }
        return null;
    }
}
```

**步骤6.** 创建自定义解释器,去解释字符串

```java
public class MyExpressionParser {
    private Stack<Interpreter> stack = new Stack<Interpreter>();

    public int parse(String str) {
        String[] strItemArray = str.split(" ");
        for (String symbol : strItemArray) {
            if (!OperatorUtil.isOperator(symbol)) {
                Interpreter numberExpression = new NumberInterpreter(symbol);
                stack.push(numberExpression);
                System.out.println(String.format("入栈: %d", numberExpression.interpret()));
            } else {
                //是运算符号，可以计算
                Interpreter firstExpression = stack.pop();
                Interpreter secondExpression = stack.pop();
                System.out.println(String.format("出栈: %d 和 %d",
                        firstExpression.interpret(), secondExpression.interpret()));
                Interpreter operator = OperatorUtil.getExpressionObject(firstExpression, secondExpression, symbol);
                System.out.println(String.format("应用运算符: %s", operator));
                int result = operator.interpret();
                NumberInterpreter resultExpression = new NumberInterpreter(result);
                stack.push(resultExpression);
                System.out.println(String.format("阶段结果入栈: %d", resultExpression.interpret()));
            }
        }
        int result = stack.pop().interpret();
        return result;
    }
}
```

**步骤7.** 测试

```java
 public static void main(String[] args) {
        //输入字符串,自己定义的一套算法
        String geelyInputStr="6 100 11 + *";
        MyExpressionParser expressionParser=new MyExpressionParser();
        int result=expressionParser.parse(geelyInputStr);
        /**
         * 结果:
         * 100+11=111 111*6=666
         */
        System.out.println("解释器计算结果: "+result);
 }
```

## 6.优点
- 语法由很多类表示,容易改变和扩展此"语言"

## 7.缺点
- 当语法规则数目太多时,增加了系统复杂度


<h1 align="center">设计模式（十八）-- 观察者模式</h1>
<hr>

> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解观察者模式

## 2.基本套路
定义:定义了对象之间的一对多依赖,让多个观察者对象同时监听某一个主题对象,当主题对象发生变化时,它的所有观察者都会收到通知并更新

类型:行为型

选择关键点:观察者与被观察者是否是多对一的关系

设计原则:遵循迪米特、开闭原则

使用概率:40%

难度系数:中

## 3.适用场景
1.关联行为场景,建立一套触发机制

## 4.使用步骤
用栗子能更好的说明问题,请继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式
#### 5.1栗子说明
- 背景:我有好几个女朋友,一直观察着我,我去夜店观察我,去泡吧也观察我
- 目的:用观察者模式模拟女朋友观察我,然后我是被观察者,我去干什么事儿都主动通知女朋友们

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建观察者,女朋友们 是观察者

```java
public interface Observer {
	void update(String state);
}
```
**步骤2.**创建我的其中一个女朋友,观察者的一个子类 实现类

```java
public class GirlFriendObserver implements Observer {
	private String name;
	public String getName() {
		return name;
	}

	public GirlFriendObserver(String name) {
		super();
		this.name = name;
	}

	@Override
	public void update(String state) {
		System.out.println(name + "接到最新消息,男朋友最新状态:" + state);
	}
}
```

**步骤3.**创建被观察者 ,我自己

```java
public abstract class Observable {

	private ArrayList<Observer> observers = new ArrayList<Observer>();

	/**
	 * 添加一个观察者
	 */
	public void attach(Observer observer) {
		observers.add(observer);
		System.out.println("我新交了一个女朋友");
	}

	/**
	 *去掉一个观察者 
	 */
	public void dettch(Observer observer) {
		observers.remove(observer);
		System.out.println("我和她分手了");
	}

	/**
	 * 通知观察者(就是通知我的女朋友们)
	 */
	public void notyfyObservers(String state) {
		for (Observer observer : observers) {
			observer.update(state);
		}
	}
}
```

**步骤4.** 创建被观察者的 子类

```java
public class MessageObservable extends Observable {
	public void change(String state) {
		notyfyObservers(state);
	}
}
```

**步骤5.** 测试,女朋友是观察者,我是被观察者,现实中是观察者一直观察被观察者,如果我去泡吧了,直接分手。在代码中,是被观察者主动告诉观察者,我去泡吧了或者大保健了,然后分手。这样可以减少资源的不必要的浪费,提高性能

```java
 public static void main(String[] args) {
        //创建2个观察者
        Observer fanbingbing = new GirlFriendObserver("范冰冰");
        Observer yangmi = new GirlFriendObserver("杨幂");

        //创建被观察者
        MessageObservable messageSubject = new MessageObservable();

        //被观察者 添加 观察者 到集合中
        messageSubject.attach(fanbingbing);
        messageSubject.attach(yangmi);
        //被观察者 通知 观察者,我都干了什么
        messageSubject.change("我在大保健");

        messageSubject.dettch(yangmi);
        messageSubject.notyfyObservers("泡吧");
 }
```

## 6.优点
- 观察者和被观察者之间建立一个抽象的耦合
- 观察者模式支持广播通信 

## 7.缺点
- 观察者之间有过多的细节依赖,提高时间消耗和程序复杂度
- 使用要得当,要避免循环调用



<h1 align="center">设计模式（十九）-- 备忘录模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解备忘录模式

## 2.基本套路
定义:保存某个对象的某个状态,以便于在适当的时候恢复对象

类型:行为型

选择关键点:是否可以在必要的时候捕捉到对象的内部状态

设计原则:遵循迪米特、开闭原则

使用概率:5%

难度系数:中

## 3.适用场景
1.保存和恢复数据相关业务场景

2.后悔的时候,即想恢复到之前的状态

## 4.使用步骤
用栗子能更好的说明问题,请继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1栗子说明
- 背景:学习的时候会记录自己的思路,然后会记下来,如果想修改,可以恢复到之前保存的状态
- 目的:用备忘录模式模拟实现

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建手记

```java
public class Article {

    private String title;
    private String content;
    private String imgs;

    public Article(String title, String content, String imgs) {
        this.title = title;
        this.content = content;
        this.imgs = imgs;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getImgs() {
        return imgs;
    }

    public void setImgs(String imgs) {
        this.imgs = imgs;
    }

    /**
     * 保存到备忘录中
     */
    public ArticleMemento saveToMemento() {
        ArticleMemento articleMemento = new ArticleMemento(this.title, this.content, this.imgs);
        return articleMemento;
    }

    public void undoFromMemento(ArticleMemento articleMemento) {
        this.title = articleMemento.getTitle();
        this.content = articleMemento.getContent();
        this.imgs = articleMemento.getImgs();
    }

    @Override
    public String toString() {
        return "Article{" +
                "title='" + title + '\'' +
                ", content='" + content + '\'' +
                ", imgs='" + imgs + '\'' +
                '}';
    }
}
```
**步骤2.**创建手记备忘

```java
public class ArticleMemento {
    private String title;
    private String content;
    private String imgs;

    public ArticleMemento(String title, String content, String imgs) {
        this.title = title;
        this.content = content;
        this.imgs = imgs;
    }

    public String getTitle() {
        return title;
    }

    public String getContent() {
        return content;
    }

    public String getImgs() {
        return imgs;
    }

    @Override
    public String toString() {
        return "ArticleMemento{" +
                "title='" + title + '\'' +
                ", content='" + content + '\'' +
                ", imgs='" + imgs + '\'' +
                '}';
    }
}
```

**步骤3.**创建手记备忘管理者

```java
public class ArticleMementoManager {

    private final Stack<ArticleMemento> ARTICLE_MEMENTO_STACK = new Stack<>();

    public ArticleMemento getMemento() {
        ArticleMemento articleMemento = ARTICLE_MEMENTO_STACK.pop();
        return articleMemento;
    }

    public void addMemento(ArticleMemento articleMemento) {
        ARTICLE_MEMENTO_STACK.push(articleMemento);
    }
}
```

**步骤4.** 测试

```java
 public static void main(String[] args) {
        ArticleMementoManager articleMementoManager = new ArticleMementoManager();

        Article article = new Article("如影随行的设计模式A", "手记内容A", "手记图片A");
        ArticleMemento articleMemento = article.saveToMemento();
        articleMementoManager.addMemento(articleMemento);
        System.out.println("标题:" + article.getTitle() + " 内容:" + article.getContent() + " 图片:" + article.getImgs() + " 暂存成功");
        System.out.println("手记完整信息:" + article);

        System.out.println("修改手记start");

        article.setTitle("如影随行的设计模式B");
        article.setContent("手记内容B");
        article.setImgs("手记图片B");

        System.out.println("修改手记end");

        System.out.println("手记完整信息:" + article);

        articleMemento = article.saveToMemento();
        articleMementoManager.addMemento(articleMemento);

        article.setTitle("如影随行的设计模式C");
        article.setContent("手记内容C");
        article.setImgs("手记图片C");

        System.out.println("暂存回退start");

        System.out.println("回退出栈1次");
        articleMemento = articleMementoManager.getMemento();
        article.undoFromMemento(articleMemento);

        System.out.println("回退出栈2次");
        articleMemento = articleMementoManager.getMemento();
        article.undoFromMemento(articleMemento);


        System.out.println("暂存回退end");
        System.out.println("手记完整信息:" + article);
 }
```

## 6.优点
- 为用户提供了一种可恢复的机制
- 存档信息的封装

## 7.缺点
- 资源占用



<h1 align="center">设计模式（二十）-- 命令模式</h1>
<hr>

> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解命令模式

## 2.基本套路
定义:将请求封装成对象,以便使用不同的请求

类型:行为型

选择关键点:请求者是否不需要关心命令的执行只知道接受者

设计原则:遵循迪米特、开闭原则

使用概率:20%

难度系数:中高

## 3.适用场景
1.请求的调用者和请求接受者需要解耦,使得调用者和接受者不直接交互

2.需要抽象出等待执行的行为

## 4.使用步骤
用栗子能更好的说明问题,请继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式
#### 5.1栗子说明
- 背景:网站上课程是有视频的,免费打开视频让大家看或者关闭这个视频收费才能看
- 目的:用命令模式模拟

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建命令接口

```java
public interface Command {
    void execute();
}
```
**步骤2.**创建课程视频

```java
public class CourseVideo {
    private String name;

    public CourseVideo(String name) {
        this.name = name;
    }
    public void open(){
        System.out.println(this.name+"课程视频开放");
    }
    public void close(){
        System.out.println(this.name+"课程视频关闭");
    }
}
```

**步骤3.**创建打开课程视频命令和关闭课程视频命令

```java
public class OpenCourseVideoCommand implements Command {
    private CourseVideo courseVideo;

    public OpenCourseVideoCommand(CourseVideo courseVideo) {
        this.courseVideo = courseVideo;
    }

    @Override
    public void execute() {
        courseVideo.open();
    }
}

public class CloseCourseVideoCommand implements Command {
    private CourseVideo courseVideo;

    public CloseCourseVideoCommand(CourseVideo courseVideo) {
        this.courseVideo = courseVideo;
    }

    @Override
    public void execute() {
        courseVideo.close();
    }
}
```

**步骤4.** 创建工作人员类可以执行一组命令

```java
public class Staff {
    private List<Command> commandList = new ArrayList<>();
    public void addCommand(Command command){
        commandList.add(command);
    }

    public void executeCommands(){
        for(Command command : commandList){
            command.execute();
        }
        commandList.clear();
    }
}
```

**步骤5.** 测试

```java
 public static void main(String[] args) {
        //创建课程
        CourseVideo courseVideo = new CourseVideo("Java设计模式");
        //创建打开命令
        OpenCourseVideoCommand openCourseVideoCommand = new OpenCourseVideoCommand(courseVideo);
        //创建关闭命令
        CloseCourseVideoCommand closeCourseVideoCommand = new CloseCourseVideoCommand(courseVideo);

        //创建工作人员
        Staff staff = new Staff();
        staff.addCommand(openCourseVideoCommand);
        staff.addCommand(closeCourseVideoCommand);

        //执行这一组命令
        staff.executeCommands();
 }
```

## 6.优点
- 降低耦合
- 容易扩展新命令或者一组命令

## 7.缺点
- 命令的无限扩展会增加类的数量,提高系统的实现复杂度



<h1 align="center">设计模式（二一）-- 中介者模式</h1>
<hr>

> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解中介者模式

## 2.基本套路
定义:定义一个封装一组对象如何交互的对象

类型:行为型

选择关键点:复杂的交互关系是否有共性可被中介者承担

设计原则:遵循迪米特，破坏单一职责

使用概率:10%

难度系数:中

## 3.适用场景
1.系统中对象之间存在复杂的引用关系,产生的相互依赖关系结构混乱且难以理解

2.交互的公共行为,如果需要改变行为则可以增加新的中介者类

## 4.使用步骤
用栗子能更好的说明问题,请继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式
#### 5.1栗子说明
- 背景:风清扬和令狐冲交流,传授独孤九剑
- 目的:用中介者模式模拟

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建中介者,可以理解为一个群,大家都可以在这里面说话

```java
public class StudyGroup {
    public static void showMessage(User user, String message){
        System.out.println(new Date().toString() + " [" + user.getName() + "] : " + message);
    }
}
```

**步骤2.**创建用户User

```java
public class User {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public User(String name) {
        this.name = name;
    }

    /**
     * 交给中介者展示信息
     * @param message
     */
    public void sendMessage(String message) {
        StudyGroup.showMessage(this, message);
    }
}
```

**步骤3.** 测试

```java
 public static void main(String[] args) {
        User fengqingyang = new User("风清扬");
        User linghuchong = new User("令狐冲");

        fengqingyang.sendMessage("传授你独孤九剑");
        linghuchong.sendMessage("OK");
 }
```

## 6.优点
- 将一对多转化成了一对一,降低程序复杂度
- 类之间解耦

## 7.缺点
- 中介者过多,导致系统复杂



<h1 align="center">设计模式（二二）-- 责任链模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解责任链模式

## 2.基本套路
定义:为请求创建一个接受此次请求对象的链

类型:行为型

选择关键点:对于每一次请求是否每个处理的对象都需要一次处理机会

设计原则:遵循迪米特

使用概率:15%

难度系数:中

## 3.适用场景
1.一个请求的处理需要多个对象当中的一个或几个协作处理

## 4.使用步骤
用栗子能更好的说明问题,请继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1栗子说明
- 背景:在网站上发布一个课程,需要两个人检查,一个是视频,一个是手记
- 目的:用责任链模式模

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建课程类

```java
public class Course {
    private String name;
    private String article;
    private String video;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getArticle() {
        return article;
    }

    public void setArticle(String article) {
        this.article = article;
    }

    public String getVideo() {
        return video;
    }

    public void setVideo(String video) {
        this.video = video;
    }

    @Override
    public String toString() {
        return "Course{" +
                "name='" + name + '\'' +
                ", article='" + article + '\'' +
                ", video='" + video + '\'' +
                '}';
    }
}
```

**步骤2.**创建抽象的批准者类

```java
public abstract class Approver {
    protected Approver approver;

    public void setNextApprover(Approver approver){
        this.approver = approver;
    }
    public abstract void deploy(Course course);
}
```

**步骤3.** 创建手记批准者和视频批准者

```java
public class ArticleApprover extends Approver {
    @Override
    public void deploy(Course course) {
        if (StringUtils.isNotEmpty(course.getArticle())) {
            System.out.println(course.getName() + "含有手记,批准");
            if (approver != null) {
                approver.deploy(course);
            }
        } else {
            System.out.println(course.getName() + "不含有手记,不批准,流程结束");
            return;
        }
    }
}

public class VideoApprover extends Approver {
    @Override
    public void deploy(Course course) {

        if (StringUtils.isNotEmpty(course.getVideo())) {
            System.out.println(course.getName() + "含有视频,批准");
            if (approver != null) {
                approver.deploy(course);
            }
        } else {
            System.out.println(course.getName() + "不含有视频,不批准,流程结束");
            return;
        }
    }
}
```

**步骤4.** 测试

```java
 public static void main(String[] args) {
        //创建手记批准者
        Approver articleApprover = new ArticleApprover();
        //创建视频批准者
        Approver videoApprover = new VideoApprover();

        //创建课程
        Course course = new Course();
        course.setName("Java设计模式精讲");
        course.setArticle("Java设计模式精讲的手记");
        course.setVideo("Java设计模式精讲的视频");

        //校验
        articleApprover.setNextApprover(videoApprover);
        articleApprover.deploy(course);
 }
```

## 6.优点
- 请求的发送者和接受者(请求的处理者)解耦
- 责任链可以动态组合

## 7.缺点
- 责任链太长或者处理时间过长,影响性能
- 责任链有可能过多


<h1 align="center">设计模式（二三）-- 访问者模式</h1>
<hr>
> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解访问者模式

## 2.基本套路
定义:封装作用于某数据结构(比如List,Set,Map等)中的个元素的操作

类型:行为型

选择关键点:数据结构是否稳定以及操作是否经常变化

设计原则:遵循倾斜的开闭原则

使用概率:5%

难度系数:高

## 3.适用场景
1.一个数据结构如(List/Set/Map等)包含很多类型对象

2.数据结构与数据操作分类

## 4.使用步骤
用栗子能更好的说明问题,请继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式
#### 5.1栗子说明
- 背景:网站上有免费课程和付费课程
- 目的:用访问者模式模拟

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建课程类

```java
public abstract class Course {
    private String name;

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    //是否接受访问
    public abstract void accept(IVisitor visitor);
}
```

**步骤2.**创建Visitor 接口

```java
public interface IVisitor {
    //访问免费课程
    void visit(FreeCourse freeCourse);

    //访问付费课程
    void visit(CodingCourse codingCourse);
}
```

**步骤3.** 创建免费课程和代码付费课程

```java
public class FreeCourse extends Course {

    @Override
    public void accept(IVisitor visitor) {
        visitor.visit(this);
    }
}

public class CodingCourse extends Course {
    private int price;

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    @Override
    public void accept(IVisitor visitor) {
        visitor.visit(this);
    }
}
```

**步骤4.** 创建Visitor的实现类

```java
public class Visitor implements IVisitor {

    //访问免费课程，打印所有免费课程名称
    @Override
    public void visit(FreeCourse freeCourse) {
        System.out.println("免费课程:"+freeCourse.getName());
    }

    //访问付费课程，打印所有实战课程名称及价格
    @Override
    public void visit(CodingCourse codingCourse) {
        System.out.println("付费课程:"+codingCourse.getName()+" 价格:"+codingCourse.getPrice()+"元");
    }
}
```

**步骤5.** 测试

```java
 public static void main(String[] args) {
        List<Course> courseList = new ArrayList<>();

        //免费课程
        FreeCourse freeCourse = new FreeCourse();
        freeCourse.setName("Android基础");

        //付费课程
        CodingCourse codingCourse = new CodingCourse();
        codingCourse.setName("Java设计模式精讲");
        codingCourse.setPrice(299);

        courseList.add(freeCourse);
        courseList.add(codingCourse);

        for (Course course : courseList) {
            course.accept(new Visitor());
        }
 }
```

## 6.优点
- 增加新的操作很容易,就是增加一个新的访问者

## 7.缺点
- 增加新的数据结构困难
- 具体元素变更比较麻烦



<h1 align="center">设计模式（二四）-- 状态模式</h1>
<hr>

> 源代码
[GitHub源代码](https://github.com/hydznsqk/MyDesignPattern)

## 1.本文目标
本文目标是为了让大家认识并理解状态模式

## 2.基本套路
定义:当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。

类型:行为型

选择关键点:这些状态是否经常在运行时需要在不同的动态之间相互转换

设计原则:遵循单一职责、依赖倒置、开闭原则

使用概率:20%

难度系数: 中

## 3.适用场景
1.一个对象在多个状态下行为不同，且这些状态可互相转换

## 4.使用步骤
用栗子能更好的说明问题,请继续往下看

## 5.举个栗子
我们用具体的代码去更好的理解这个设计模式

#### 5.1栗子说明
- 背景:播放一个课程,有多种状态,播放,暂停,快进,停止
- 目的:用状态模式模拟

#### 5.2使用步骤
实现代码如下:

**步骤1.**创建课程视频状态  抽象类

```java
public abstract class CourseVideoState {
    protected CourseVideoContext courseVideoContext;

    public void setCourseVideoContext(CourseVideoContext courseVideoContext) {
        this.courseVideoContext = courseVideoContext;
    }

    public abstract void play();
    public abstract void speed();
    public abstract void pause();
    public abstract void stop();
}
```

**步骤2.**创建播放,暂停,快进,停止等状态类

```java
public class PlayState extends CourseVideoState {

    @Override
    public void play() {
        System.out.println("正常播放课程视频状态");
    }

    @Override
    public void speed() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.SPEED_STATE);
    }

    @Override
    public void pause() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PAUSE_STATE);
    }

    @Override
    public void stop() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.STOP_STATE);
    }
}


public class PauseState extends CourseVideoState {

    @Override
    public void play() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PLAY_STATE);
    }

    @Override
    public void speed() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.SPEED_STATE);
    }

    @Override
    public void pause() {
        System.out.println("暂停播放课程视频状态");
    }

    @Override
    public void stop() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.STOP_STATE);
    }
}

public class SpeedState extends CourseVideoState {
    @Override
    public void play() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PLAY_STATE);
    }

    @Override
    public void speed() {
        System.out.println("快进播放课程视频状态");
    }

    @Override
    public void pause() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PAUSE_STATE);
    }

    @Override
    public void stop() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.STOP_STATE);
    }
}

public class StopState extends CourseVideoState {
    @Override
    public void play() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PLAY_STATE);
    }

    @Override
    public void speed() {
        System.out.println("ERROR 停止状态不能快进!!");
    }

    @Override
    public void pause() {
        System.out.println("ERROR 停止状态不能暂停!!");
    }

    @Override
    public void stop() {
        System.out.println("停止播放课程视频状态");
    }
}
```

**步骤3.** 创建课程视频内容管理类

```java
public class CourseVideoContext {

    private CourseVideoState courseVideoState;
    public final static PlayState PLAY_STATE = new PlayState();
    public final static StopState STOP_STATE = new StopState();
    public final static PauseState PAUSE_STATE = new PauseState();
    public final static SpeedState SPEED_STATE = new SpeedState();

    public CourseVideoState getCourseVideoState() {
        return courseVideoState;
    }

    public void setCourseVideoState(CourseVideoState courseVideoState) {
        this.courseVideoState = courseVideoState;
        this.courseVideoState.setCourseVideoContext(this);
    }
    public void play(){
        this.courseVideoState.play();
    }

    public void speed(){
        this.courseVideoState.speed();
    }

    public void stop(){
        this.courseVideoState.stop();
    }

    public void pause(){
        this.courseVideoState.pause();
    }
}
```

**步骤4.** 测试

```java
 public static void main(String[] args) {
        CourseVideoContext courseVideoContext = new CourseVideoContext();
        courseVideoContext.setCourseVideoState(new PlayState());

        System.out.println("当前状态:"+courseVideoContext.getCourseVideoState().getClass().getSimpleName());
        courseVideoContext.pause();

        System.out.println("当前状态:"+courseVideoContext.getCourseVideoState().getClass().getSimpleName());
        courseVideoContext.speed();

        System.out.println("当前状态:"+courseVideoContext.getCourseVideoState().getClass().getSimpleName());
        courseVideoContext.stop();

        System.out.println("当前状态:"+courseVideoContext.getCourseVideoState().getClass().getSimpleName());
        courseVideoContext.speed();
 }
```

## 6.优点
- 状态模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来
- 所有状态相关的代码都存在于某个ConcereteState中，所以通过定义新的子类很容易地增加新的状态和转换
- 状态模式通过把各种状态转移逻辑分不到State的子类之间，来减少相互间的依赖

## 7.缺点
- 导致较多的ConcreteState子类


#总结
本文只是对所有行为型模式的分享,接下来会继续分享其他Android干货,大家可以持续进行关注,[信仰年輕的设计模式](https://www.jianshu.com/u/f07649312c75),蟹蟹啦。






