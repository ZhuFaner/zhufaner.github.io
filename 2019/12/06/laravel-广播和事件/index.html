<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Tech Team of Zhufaner Inc."><meta name="description" conauthortent="住范儿技术团队博客"><link rel="alternative" href="/atom.xml" title="住范儿技术团队" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><title>Laravel 事件和广播 - 住范儿技术团队</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create', 'UA-99090733-1', 'auto');ga('send', 'pageview');
</script><!-- Hotjar Tracking Code for ochukai.me --></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">住范儿技术团队</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/archives" class="head-nav__link">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head">  <time datetime="2019-12-06T09:59:00.000Z" class="post__time">十二月 6, 2019<a class="author">作者：吉鹏</a></time><h1 class="post__title">Laravel 事件和广播</h1><div class="post__main echo"><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>事件可以解耦系统程序代码，使系统模块分明。事件本质上是一对多的关系，即当某个事件发生，会触发一系列的系统更新操作。php 提供了 SplSubject, SplObserver, SplObjectStorage 标准库接口用来实现事件功能。<br>laravel 的事件提供了一个简单的观察者实现，允许你在应用中订阅和监听各种发生的事件。在阅读之前，需要对 laravel 的服务容器和服务提供者有些微了解。</p>
<h2 id="事件实现"><a href="#事件实现" class="headerlink" title="事件实现"></a>事件实现</h2><h3 id="EventServiceProvider-服务提供者"><a href="#EventServiceProvider-服务提供者" class="headerlink" title="EventServiceProvider 服务提供者"></a>EventServiceProvider 服务提供者</h3><p>在 laravel 系统中，EventServiceProvider 负责提供事件的实现与调度，作为 laravel 核心服务提供者，在系统初始化函数中就被注册，核心代码块为</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/laravel/framework/src/Illuminate/Events/EventServiceProvider.php</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;app-&gt;singleton(<span class="string">'events'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($app)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> Dispatcher($app))-&gt;setQueueResolver(<span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($app)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> $app-&gt;make(QueueFactoryContract::class);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>核心是往 laravel 的服务容器中绑定事件接口和事件的实现类</li>
<li>Dispatcher 类是事件实现的核心类</li>
<li>QueueFactoryContract 是标注对应的队列实现类</li>
</ul>
<p>为了简明逻辑，将核心放到事件实现上，可以忽略队列相关东西，可以将代码简化为</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">$this</span>-&gt;app-&gt;singleton(<span class="string">'events'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($app)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">new</span> Dispatcher($app));</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Dispatcher-核心类"><a href="#Dispatcher-核心类" class="headerlink" title="Dispatcher 核心类"></a>Dispatcher 核心类</h3><p>   Dispatcher 类是 laravel 提供事件服务的核心代码，事件本质上就两个核心函数</p>
<ol>
<li>listen 方法，负责绑定事件名称和事件监听器代码的对应关系，事件名称通过判断是否包含 “ * “ 分为明确事件名称和通配符事件名称</li>
<li>dispatch 方法，负责调度监听器代码，完成系统事件更新</li>
</ol>
<h4 id="listen-方法解析"><a href="#listen-方法解析" class="headerlink" title="listen 方法解析"></a>listen 方法解析</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">listen</span><span class="params">($events, $listener)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">foreach</span> ((<span class="keyword">array</span>) $events <span class="keyword">as</span> $event) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Str::contains($event, <span class="string">'*'</span>)) &#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;setupWildcardListen($event, $listener);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;listeners[$event][] = <span class="keyword">$this</span>-&gt;makeListener($listener);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>laravel 将事件映射分别存储到 wildcards 和 listeners 属性中</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">makeListener</span><span class="params">($listener, $wildcard = false)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (is_string($listener)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">$this</span>-&gt;createClassListener($listener, $wildcard);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">($event, $payload)</span> <span class="title">use</span> <span class="params">($listener, $wildcard)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ($wildcard) &#123;</span><br><span class="line">			<span class="keyword">return</span> $listener($event, $payload);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> $listener(...array_values($payload));</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 makeListener 方法中，分依据  $listener 参数类型不同，分情况解析监听器代码</p>
<ol>
<li>当 $listener 为字符串时，会通过 createClassListener 方法进一步解析处理</li>
<li>当 $listener 为闭包函数时，会进一步进行包装，将事件名和参数作为闭包函数的参数，在闭包函数内，依据 $wildcard 直接调用对应的监听器代码。这一步封装主要为了在调度时方便统一处理</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">createClassListener</span><span class="params">($listener, $wildcard = false)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">($event, $payload)</span> <span class="title">use</span> <span class="params">($listener, $wildcard)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ($wildcard) &#123;</span><br><span class="line">			<span class="keyword">return</span> call_user_func(<span class="keyword">$this</span>-&gt;createClassCallable($listener), $event, $payload);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> call_user_func_array(</span><br><span class="line">			<span class="keyword">$this</span>-&gt;createClassCallable($listener), $payload</span><br><span class="line">		);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createClassCallable</span><span class="params">($listener)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	[$class, $method] = <span class="keyword">$this</span>-&gt;parseClassCallable($listener);</span><br><span class="line">	***省了队列的一些处理****</span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">$this</span>-&gt;container-&gt;make($class), $method];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">parseClassCallable</span><span class="params">($listener)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Str::parseCallback($listener, <span class="string">'handle'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先对字符进行处理，laravel 预期的字符串为 \mespace\XXXclass@method ，parseClassCallable 会用 @ 符号截取字符串，获得类名和方法名，方法名默认为 handle</li>
<li>createClassCallable 方法会通过服务容器，解析出监听器类实例</li>
<li>createClassListener 方法也会进行闭包封装，参数依然是事件名称和参数，这一点和上述对闭包的封装一样</li>
</ol>
<h4 id="dispatch-方法解析"><a href="#dispatch-方法解析" class="headerlink" title="dispatch 方法解析"></a>dispatch 方法解析</h4><p>当对应事件触发时，系统会通过 dispatch 方法进行调度，调用之前注册过的监听函数，完成事件更新任务。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($event, $payload = [], $halt = false)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	[$event, $payload] = <span class="keyword">$this</span>-&gt;parseEventAndPayload(</span><br><span class="line">		$event, $payload</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	****  省略队列处理代码  ****</span><br><span class="line">	$responses = [];</span><br><span class="line">	<span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;getListeners($event) <span class="keyword">as</span> $listener) &#123;</span><br><span class="line">		$response = $listener($event, $payload);</span><br><span class="line">		<span class="keyword">if</span> ($halt &amp;&amp; ! is_null($response)) &#123;</span><br><span class="line">			<span class="keyword">return</span> $response;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ($response === <span class="keyword">false</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		$responses[] = $response;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> $halt ? <span class="keyword">null</span> : $responses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是事件调度的核心代码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">parseEventAndPayload</span><span class="params">($event, $payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (is_object($event)) &#123;</span><br><span class="line">		[$payload, $event] = [[$event], get_class($event)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> [$event, Arr::wrap($payload)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要是为了解析一下事件名和参数，$event 解析为字符串，$payload 解析为数组。当参数 $event 为对象时，  laravel 会解析出类名作为事件名称，并且将类实例作为  $payload 数组参数返回</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getListeners</span><span class="params">($eventName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	$listeners = <span class="keyword">$this</span>-&gt;listeners[$eventName] ?? [];</span><br><span class="line">	$listeners = array_merge(</span><br><span class="line">		$listeners,</span><br><span class="line">		<span class="keyword">$this</span>-&gt;wildcardsCache[$eventName] ?? <span class="keyword">$this</span>-&gt;getWildcardListeners($eventName)</span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">return</span> class_exists($eventName, <span class="keyword">false</span>)</span><br><span class="line">				? <span class="keyword">$this</span>-&gt;addInterfaceListeners($eventName, $listeners)</span><br><span class="line">				: $listeners;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getWildcardListeners</span><span class="params">($eventName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	$wildcards = [];</span><br><span class="line">	<span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;wildcards <span class="keyword">as</span> $key =&gt; $listeners) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Str::is($key, $eventName)) &#123;</span><br><span class="line">			$wildcards = array_merge($wildcards, $listeners);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">$this</span>-&gt;wildcardsCache[$eventName] = $wildcards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">addInterfaceListeners</span><span class="params">($eventName, array $listeners = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">foreach</span> (class_implements($eventName) <span class="keyword">as</span> $interface) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;listeners[$interface])) &#123;</span><br><span class="line">			<span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;listeners[$interface] <span class="keyword">as</span> $names) &#123;</span><br><span class="line">				$listeners = array_merge($listeners, (<span class="keyword">array</span>) $names);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> $listeners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>getWildcardListeners 方法会解析 wildcards 中的监听事件，这一部分主要是带通配符的事件名称，并且解析完后会进行内存缓存</li>
<li>addInterfaceListeners 方法会向上发散，会找到事件类所有实现的接口类，并且进一步解析 listeners 中是否有对应接口类的监听器函数，借此实现了类似 JavaScript 中的事件冒泡原理</li>
<li>获取到事件的所有监听器函数之后，会按照顺序依次调用，由参数 halt 或者 监听器函数返回值( false ) 来决定是否停止继续执行剩余监听器代码，所以，在绑定事件监听器时，绑定的顺序也是很重要的</li>
</ol>
<h5 id="Dispatcher-的其余代码"><a href="#Dispatcher-的其余代码" class="headerlink" title="Dispatcher 的其余代码"></a>Dispatcher 的其余代码</h5><p>打开 Dispatcher 实现的接口类，发现还有一些其他方法，例如：push、flush、forget、hasListeners 等等，这些都是一些辅助的方法函数，都是对 listen / dispatch 的调用，或者是对 listeners / wildcards / wildcardsCache 的处理</p>
<h3 id="laravel-对队列的使用"><a href="#laravel-对队列的使用" class="headerlink" title="laravel 对队列的使用"></a>laravel 对队列的使用</h3><h4 id="事件注册机制"><a href="#事件注册机制" class="headerlink" title="事件注册机制"></a>事件注册机制</h4><p>  通过上述分析，事件注册本质上就是调用 listener 函数，进行事件名和事件处理函数的关系绑定。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$event  = $app-&gt;make(<span class="string">"events"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定事件名称 和 类字符串</span></span><br><span class="line">$event-&gt;listen(<span class="string">'order'</span>,App\Listeners\OrderListenerOne::class);</span><br><span class="line">$event-&gt;listen(App\Events\OrderEvent::class,App\Listeners\OrderListenerOne::class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定事件名称 和 闭包函数 </span></span><br><span class="line">$event-&gt;listen(<span class="string">'order'</span>,<span class="function"><span class="keyword">function</span><span class="params">( $a , $b )</span></span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line">  <span class="keyword">echo</span> $a, <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">  <span class="keyword">echo</span> $b, <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="事件触发调度"><a href="#事件触发调度" class="headerlink" title="事件触发调度"></a>事件触发调度</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 字符串名称触发</span></span><br><span class="line">$event-&gt;dispatch(<span class="string">"order"</span>,[<span class="number">1</span>,<span class="number">11</span>,<span class="number">22</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类事件触发</span></span><br><span class="line">$one = <span class="keyword">new</span> App\Events\OrderEvent(<span class="number">1</span>);</span><br><span class="line">$event-&gt;dispatch($one,[<span class="number">1</span>,<span class="number">11</span>,<span class="number">22</span>]); <span class="comment">// 如果是类的话，后边参数会被类覆盖，</span></span><br></pre></td></tr></table></figure>

<h3 id="laravel-事件说明"><a href="#laravel-事件说明" class="headerlink" title="laravel 事件说明"></a>laravel 事件说明</h3><ol>
<li>laravel 事件处理，每个地方都在依据是否带有通配符进行分情况处理，带通配符的话，会将事件名作为参数传递</li>
<li>如果触发事件的是类实例，laravel 会解析出类名作为事件名称</li>
<li>laravel 的事件也有向上冒泡功能  </li>
</ol>
<h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><h2 id="laravel-广播介绍"><a href="#laravel-广播介绍" class="headerlink" title="laravel 广播介绍"></a>laravel 广播介绍</h2><p>   laravel 的广播模块，本质是利用 websocket 建立客户端和服务端的双向链接，通过各种频道进行通信，完成信息的更新显示</p>
<h2 id="开工前准备"><a href="#开工前准备" class="headerlink" title="开工前准备"></a>开工前准备</h2><ul>
<li>laravel 6.0 版本</li>
<li>laravel 队列，本例使用 redis 作为队列驱动</li>
<li>laravel/ui 提供的前端脚手架</li>
<li>laravel 事件</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li>redis 相关配置</li>
<li>开启广播服务提供者<br>  在 config/app.php 中取消 App\Providers\BroadcastServiceProvider::class,  前边的注释</li>
<li>设置队列、广播为 redis 驱动<br> 在 .env 中，设置<br>  BROADCAST_DRIVER=redis<br>  QUEUE_CONNECTION=redis</li>
</ul>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="创建广播事件"><a href="#创建广播事件" class="headerlink" title="创建广播事件"></a>创建广播事件</h3><ol>
<li>使用 php artisan make:event PushMsgEvent，创建事件类 </li>
<li>编写事件类</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PushMsgEvent</span> <span class="keyword">implements</span> <span class="title">ShouldBroadcast</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">	<span class="keyword">use</span> <span class="title">Dispatchable</span>, <span class="title">InteractsWithSockets</span>, <span class="title">SerializesModels</span>;</span><br><span class="line">	<span class="keyword">public</span> $msg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  定义 msg 变量，保存弹幕消息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">( $msg )</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 简单的消息列表</span></span><br><span class="line">		<span class="keyword">$this</span>-&gt;msg = $msg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  弹幕所有人都可以收到，所以返回公共频道就 OK 的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">broadcastOn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Channel(<span class="string">'push'</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  重命名一下广播名称，一般默认为类名</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">broadcastAs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="string">'push.msg'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编写路由及控制器，用于展示弹幕和发送弹幕</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BroadcastingController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 展示弹幕显示页面</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> view(<span class="string">"broadcasting.index"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 接受前端弹幕请求，并触发广播事件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">put</span><span class="params">( Request $request )</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		broadcast(  <span class="keyword">new</span> PushMsgEvent( $request-&gt;msg )  );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安装各种需要的-node-包"><a href="#安装各种需要的-node-包" class="headerlink" title="安装各种需要的 node 包"></a>安装各种需要的 node 包</h3><ol>
<li><p>laravel-echo-server 包，与 laravel 兼容的 Socket.IO 服务器</p>
<ul>
<li>npm install -g laravel-echo-server  全局安装</li>
<li>laravel-echo-server init  初始化配置信息，在根目录下生成 laravel-echo-server.json 文件</li>
<li>laravel-echo-server start | stop ， Socket.IO  的开启或关闭，这个需要使用守护进程在服务器上运行</li>
</ul>
</li>
<li><p>socket.io  客户端</p>
<ul>
<li>npm install  –save laravel-echo </li>
<li>npm install  –save socket.io-client</li>
</ul>
</li>
</ol>
<h3 id="前端页面编写"><a href="#前端页面编写" class="headerlink" title="前端页面编写"></a>前端页面编写</h3><ol>
<li><p>修改 webpack.min.js ，生成单独使用的 broadcasting.js 文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mix.js(<span class="string">'resources/js/app.js'</span>, <span class="string">'public/js'</span>)</span><br><span class="line">      .js(<span class="string">'resources/js/vue-component.js'</span>, <span class="string">'public/js'</span>)</span><br><span class="line">      .js(<span class="string">'resources/js/broadcasting.js'</span>, <span class="string">'public/js'</span>)  <span class="comment">/// 新增</span></span><br><span class="line">      .sass(<span class="string">'resources/sass/app.scss'</span>, <span class="string">'public/css'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 resources/js/broadcasting.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入该引入的包</span></span><br><span class="line"><span class="keyword">import</span> Echo <span class="keyword">from</span> <span class="string">'laravel-echo'</span>;</span><br><span class="line"><span class="built_in">window</span>.io = <span class="built_in">require</span>(<span class="string">'socket.io-client'</span>);</span><br><span class="line"><span class="built_in">window</span>.Echo = <span class="keyword">new</span> Echo(&#123;</span><br><span class="line">  broadcaster: <span class="string">'socket.io'</span>,</span><br><span class="line">  host: <span class="built_in">window</span>.location.hostname + <span class="string">':6001'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.Echo.channel(<span class="string">'push'</span>)</span><br><span class="line">    .listen(<span class="string">'.push.msg'</span>, (e) =&gt; &#123;</span><br><span class="line">        alert( e.msg );  <span class="comment">// 这里只是弹出弹幕消息，滚动的效果就不做了</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 npm run dev 生成 broadcasting.js 文件</p>
</li>
<li><p>编写 broadcasting.index blade 文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-container container"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-12"</span> <span class="attr">style</span>=<span class="string">"min-height: 600px;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;&#123; asset('js/broadcasting.js') &#125;&#125;"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="开始验收效果"><a href="#开始验收效果" class="headerlink" title="开始验收效果"></a>开始验收效果</h1><ol>
<li>开启 Socket.IO 服务端进程，laravel-echo-server start </li>
<li>开始队列处理进程 php artisan queue:work –timeout=30</li>
<li>利用 php 提供的内部服务器 php artisan serve</li>
<li>在输入弹幕消息之后，弹幕展示页面便会将消息弹出</li>
</ol>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/laravel/" class="post__tag__link">laravel</a></li><li class="post__tag__item"><a href="/tags/事件/" class="post__tag__link">事件</a></li><li class="post__tag__item"><a href="/tags/广播/" class="post__tag__link">广播</a></li></ul></footer></article><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript></div></div></main><footer class="foot"><div class="foot-copy u-fl"><span>©2019 </span><a href="https://github.com/zhufaner">Tech Team of Zhufaner Inc.</a></div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/2019/12/07/Laravel-服务容器/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><a title="Next" href="/2018/12/05/设计模式系列（三）-- 行为型设计模式/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})(document,"script","zhu-fan-er-ji-zhu-tuan-dui","embed");
</script><div style="display: none;"><script src="https://s4.cnzz.com/z_stat.php?id=1261929418&web_id=1261929418" language="JavaScript"></script></div><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>