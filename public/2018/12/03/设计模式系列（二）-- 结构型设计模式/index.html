<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Tech Team of Zhufaner Inc."><meta name="description" conauthortent="住范儿技术团队博客"><link rel="alternative" href="/atom.xml" title="住范儿技术团队" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><title>设计模式系列（二）-- 结构型设计模式 - 住范儿技术团队</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create', 'UA-99090733-1', 'auto');ga('send', 'pageview');
</script><!-- Hotjar Tracking Code for ochukai.me --></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">住范儿技术团队</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/archives" class="head-nav__link">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head">  <time datetime="2018-12-03T11:37:10.000Z" class="post__time">十二月 3, 2018<a href="https://github.com/hydznsqk" class="author">作者：侯亚东</a></time><h1 class="post__title">设计模式系列（二）-- 结构型设计模式</h1><div class="post__main echo"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android设计模式,共分为三大类,分别是:创建型模式,行为型模式和结构型模式。接第一篇创建型文章之后的第二篇,本篇分享的是所有的结构型设计模式。如果想单独看某一个设计模式,可以点击<a href="https://www.jianshu.com/u/f07649312c75" target="_blank" rel="noopener">信仰年輕的设计模式</a>。</p>
<p></p><h1 align="center">设计模式（七）– 外观模式</h1><p></p>
<p><hr></p>
<blockquote>
<p>源代码<br><a href="https://github.com/hydznsqk/MyDesignPattern" target="_blank" rel="noopener">GitHub源代码</a></p>
</blockquote>
<h2 id="1-本文目标"><a href="#1-本文目标" class="headerlink" title="1.本文目标"></a>1.本文目标</h2><p>本文目标是为了让大家认识并理解外观模式</p>
<h2 id="2-基本套路"><a href="#2-基本套路" class="headerlink" title="2.基本套路"></a>2.基本套路</h2><p>定义:又叫门面模式,提供了一个统一的接口,用来访问一个或多个子系统中的一群接口</p>
<p>类型:结构型</p>
<p>选择关键点:子系统对外提供服务是否需要依赖很多的类</p>
<p>设计原则:遵循迪米特</p>
<p>使用概率:60%</p>
<p>难度系数:中</p>
<h2 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3.适用场景"></a>3.适用场景</h2><p>1.子系统越来越复杂,增加外观模式提供简单调用接口</p>
<p>2.构建多层结构,利用外观对象作为每层的入口,简化层间调用</p>
<h2 id="4-使用步骤"><a href="#4-使用步骤" class="headerlink" title="4.使用步骤"></a>4.使用步骤</h2><p>用具体的栗子更容易说明问题,继续往下看</p>
<h2 id="5-举个栗子"><a href="#5-举个栗子" class="headerlink" title="5.举个栗子"></a>5.举个栗子</h2><p>我们用具体的代码去更好的理解这个设计模式</p>
<h4 id="5-1栗子说明"><a href="#5-1栗子说明" class="headerlink" title="5.1栗子说明"></a>5.1栗子说明</h4><ul>
<li>背景:某电商平台上面有积分可以换小礼物</li>
<li>目的:兑换礼物需要走好几个系统(资格兑换子系统,积分支付子系统,物流服务子系统),希望使用外观模式统一管理</li>
</ul>
<h4 id="5-2使用步骤"><a href="#5-2使用步骤" class="headerlink" title="5.2使用步骤"></a>5.2使用步骤</h4><p>实现代码如下:</p>
<p><strong>步骤1.</strong>创建积分礼物类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class PointGift &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public PointGift(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤2.</strong>创建资格兑换子系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class QualifyService &#123;</span><br><span class="line">    public boolean isAvailable(PointGift pointsGift)&#123;</span><br><span class="line">        System.out.println(&quot;校验&quot;+pointsGift.getName()+&quot; 积分资格通过,库存通过&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤3.</strong>创建积分支付子系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PointsPaymentService &#123;</span><br><span class="line">    public boolean pay(PointGift pointsGift) &#123;</span><br><span class="line">        //扣减积分</span><br><span class="line">        System.out.println(&quot;支付&quot; + pointsGift.getName() + &quot; 积分成功&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤4.</strong> 创建物流服务子系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class LogisticsService &#123;</span><br><span class="line">    public String shipGift(PointGift pointsGift)&#123;</span><br><span class="line">        //物流系统的对接逻辑</span><br><span class="line">        System.out.println(pointsGift.getName()+&quot;进入物流系统&quot;);</span><br><span class="line">        String logisticsOrderNo = &quot;666&quot;;//物流订单ID</span><br><span class="line">        return logisticsOrderNo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤5.</strong> 创建外观类,统一管理上面的3个子系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class GiftExchangeService &#123;</span><br><span class="line">    private QualifyService mQualifyService = new QualifyService();//资格兑换子系统</span><br><span class="line">    private PointsPaymentService mPointsPaymentService = new PointsPaymentService();//积分支付子系统</span><br><span class="line">    private LogisticsService mLogisticsService = new LogisticsService();//物流子系统</span><br><span class="line"></span><br><span class="line">    public void giftExchange(PointGift pointsGift)&#123;</span><br><span class="line">        if(mQualifyService.isAvailable(pointsGift))&#123;</span><br><span class="line">            //资格校验通过</span><br><span class="line">            if(mPointsPaymentService.pay(pointsGift))&#123;</span><br><span class="line">                //如果支付积分成功</span><br><span class="line">                String shippingOrderNo = mLogisticsService.shipGift(pointsGift);</span><br><span class="line">                System.out.println(&quot;物流系统下单成功,订单号是:&quot;+shippingOrderNo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤6.</strong> 测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       PointGift pointsGift = new PointGift(&quot;鼠标&quot;);</span><br><span class="line">       GiftExchangeService giftExchangeService = new GiftExchangeService();</span><br><span class="line">       giftExchangeService.giftExchange(pointsGift);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3代码总结思考"><a href="#5-3代码总结思考" class="headerlink" title="5.3代码总结思考"></a>5.3代码总结思考</h4><p>就是说兑换这个小礼物需要走3个子系统,然后我们提供一个外观类对象(GiftExchangeService),提供统一的入口,让外观类(GiftExchangeService)去和3个子系统通信,然后我们的应用层(也就是FacadeTest这个类)只需要和外观类通信就完了,应用层(TestFacade)&lt;=&gt;外观类(GiftExchangeService)&lt;=&gt;3个子系统(QualifyService,PointsPaymentService,LogisticsService)</p>
<h2 id="6-优点"><a href="#6-优点" class="headerlink" title="6.优点"></a>6.优点</h2><ul>
<li>简化了调用过程,无需了解深入子系统,防止带来风险</li>
<li>减少系统依赖,松散耦合(客户端不和子系统直接交流,而是通过外观模式进行交流)</li>
<li>更好的划分访问层次</li>
<li>符合迪米特法则,即最少知道原则(客户端不需要了解子系统内部的实现,只需要和外观类交互就完了)</li>
</ul>
<h2 id="7-缺点"><a href="#7-缺点" class="headerlink" title="7.缺点"></a>7.缺点</h2><ul>
<li>增加子系统,扩展子系统行为容易引入风险</li>
<li>不符合开闭原则</li>
</ul>
<p></p><h1 align="center">设计模式（八）– 装饰器模式</h1><p></p>
<p><hr></p>
<blockquote>
<p>源代码<br><a href="https://github.com/hydznsqk/MyDesignPattern" target="_blank" rel="noopener">GitHub源代码</a></p>
</blockquote>
<h2 id="1-本文目标-1"><a href="#1-本文目标-1" class="headerlink" title="1.本文目标"></a>1.本文目标</h2><p>本文目标是为了让大家认识并理解装饰器模式</p>
<h2 id="2-基本套路-1"><a href="#2-基本套路-1" class="headerlink" title="2.基本套路"></a>2.基本套路</h2><p>定义:在不改变原有对象的基础之上,将功能附加到对象上</p>
<p>类型:结构型</p>
<p>选择关键点:添加的功能是否需要动态组装</p>
<p>设计原则:遵循迪米特、单一职责、开闭原则，破坏里氏替换，体现功能复用</p>
<p>使用概率:99.99999%</p>
<p>难度系数:中</p>
<h2 id="3-适用场景-1"><a href="#3-适用场景-1" class="headerlink" title="3.适用场景"></a>3.适用场景</h2><p>1.扩展一个类的功能或给一个类添加附加职责</p>
<p>2.动态的给一个对象添加功能,这些功能可以再动态的撤销</p>
<h2 id="4-使用步骤-1"><a href="#4-使用步骤-1" class="headerlink" title="4.使用步骤"></a>4.使用步骤</h2><p>用具体的栗子更容易说明问题,继续往下看</p>
<h2 id="5-举个栗子-1"><a href="#5-举个栗子-1" class="headerlink" title="5.举个栗子"></a>5.举个栗子</h2><p>我们用具体的代码去更好的理解这个设计模式</p>
<h4 id="5-1栗子说明-1"><a href="#5-1栗子说明-1" class="headerlink" title="5.1栗子说明"></a>5.1栗子说明</h4><ul>
<li>背景:公司的小伙伴小王饿了,想买个煎饼</li>
<li>目的:不仅仅是吃个煎饼,他还想加蛋,加烤肠,希望用装饰器模式实现</li>
</ul>
<h4 id="5-2使用步骤-1"><a href="#5-2使用步骤-1" class="headerlink" title="5.2使用步骤"></a>5.2使用步骤</h4><p>实现代码如下:</p>
<p><strong>步骤1.</strong>创建抽象的实体类(抽象的煎饼)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ABatterCake &#123;</span><br><span class="line">    public abstract String getDesc();</span><br><span class="line">    public abstract int cost();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤2.</strong>创建具体的实体类(具体的煎饼)继承抽象的实体类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class BatterCake extends  ABatterCake &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getDesc() &#123;</span><br><span class="line">        return &quot;煎饼&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int cost() &#123;</span><br><span class="line">        return 8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤3.</strong>创建抽象的装饰类,继承抽象的实体类(抽象的煎饼)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class AbstractDecorator  extends ABatterCake&#123;</span><br><span class="line">    private ABatterCake mBatterCake;//抽象的煎饼,当然也可以传具体的煎饼</span><br><span class="line">    public AbstractDecorator(ABatterCake mBatterCake) &#123;</span><br><span class="line">        this.mBatterCake = mBatterCake;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getDesc() &#123;</span><br><span class="line">        return this.mBatterCake.getDesc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int cost() &#123;</span><br><span class="line">        return this.mBatterCake.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤4.</strong> 创建具体的装饰类(鸡蛋装饰类),继承抽象的装饰类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class EggDecorator extends AbstractDecorator &#123;</span><br><span class="line"></span><br><span class="line">    public EggDecorator(ABatterCake mBatterCake) &#123;</span><br><span class="line">        super(mBatterCake);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getDesc() &#123;</span><br><span class="line">        return super.getDesc()+&quot;加一个鸡蛋&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int cost() &#123;</span><br><span class="line">        return super.cost()+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤5.</strong> 创建具体的装饰类(烤肠装饰类),继承抽象的装饰类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SausageDecorator extends AbstractDecorator &#123;</span><br><span class="line">    public SausageDecorator(ABatterCake mBatterCake) &#123;</span><br><span class="line">        super(mBatterCake);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getDesc() &#123;</span><br><span class="line">        return super.getDesc()+&quot;加一个烤肠&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int cost() &#123;</span><br><span class="line">        return super.cost()+2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤6.</strong> 测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       ABatterCake batterCake;</span><br><span class="line">       //煎饼</span><br><span class="line">       batterCake = new com.yadong.pattern.structural.decorator.v2.BatterCake();</span><br><span class="line">       //加蛋</span><br><span class="line">       batterCake = new EggDecorator(batterCake);</span><br><span class="line">       //在加蛋</span><br><span class="line">       batterCake = new EggDecorator(batterCake);</span><br><span class="line">       //加个烤肠</span><br><span class="line">       batterCake = new SausageDecorator(batterCake);</span><br><span class="line">       /**</span><br><span class="line">        * 输出结果:</span><br><span class="line">        * 8+1+1+2=12块钱</span><br><span class="line">        * 煎饼加一个鸡蛋加一个鸡蛋加一个烤肠 销售价格:12</span><br><span class="line">        */</span><br><span class="line">       System.out.println(batterCake.getDesc()+&quot; 销售价格:&quot;+batterCake.cost());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 另外一种写法,连起来写</span><br><span class="line">        * 输出结果:</span><br><span class="line">        * 煎饼加一个鸡蛋加一个烤肠加一个烤肠 销售价格:13</span><br><span class="line">        * 煎饼+蛋+烤肠+烤肠</span><br><span class="line">        * 8+1+2+2=13块钱</span><br><span class="line">        */</span><br><span class="line">       SausageDecorator sausageBatterCake= new SausageDecorator(new SausageDecorator(new EggDecorator(new BatterCake())));</span><br><span class="line">       System.out.println(sausageBatterCake.getDesc()+&quot; 销售价格:&quot;+sausageBatterCake.cost());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-优点-1"><a href="#6-优点-1" class="headerlink" title="6.优点"></a>6.优点</h2><ul>
<li>继承的有力补充,比继承灵活,不改变原有对象的情况下给一个对象扩展功能</li>
<li>通过使用不同装饰类以及这些装饰类的排列组合,可以实现不同效果</li>
<li>符合开闭原则</li>
</ul>
<h2 id="7-缺点-1"><a href="#7-缺点-1" class="headerlink" title="7.缺点"></a>7.缺点</h2><ul>
<li>会出现更多的代码,更多的类,增加程序复杂性</li>
<li>动态装饰时,多层装饰会更复杂</li>
</ul>
<p></p><h1 align="center">设计模式（九）– 适配器模式</h1><p></p>
<p><hr></p>
<blockquote>
<p>源代码<br><a href="https://github.com/hydznsqk/MyDesignPattern" target="_blank" rel="noopener">GitHub源代码</a></p>
</blockquote>
<h2 id="1-本文目标-2"><a href="#1-本文目标-2" class="headerlink" title="1.本文目标"></a>1.本文目标</h2><p>本文目标是为了让大家认识并理解适配器模式</p>
<h2 id="2-基本套路-2"><a href="#2-基本套路-2" class="headerlink" title="2.基本套路"></a>2.基本套路</h2><p>定义:将一个类的接口转换成客户期望的另一个接口</p>
<p>类型:结构型</p>
<p>选择关键点:定制适配器的选择关键点在于是否有更加优良的替代方案，缺省适配器的选择关键点在于接口中的方法是否可以不全部提供，且都有缺省方案</p>
<p>设计原则:遵循开闭原则、体现功能复用</p>
<p>使用概率:40%</p>
<p>难度系数:中</p>
<h2 id="3-适用场景-2"><a href="#3-适用场景-2" class="headerlink" title="3.适用场景"></a>3.适用场景</h2><p>1.已经存在的类,它的方法和需求不匹配时(方法结果相同或相似)</p>
<p>2.不是软件设计阶段考虑的设计模式,是随着软件维护,由于不同产品,不同厂家造成功能类似而接口不相同情况下的解决方案</p>
<h2 id="4-使用步骤-2"><a href="#4-使用步骤-2" class="headerlink" title="4.使用步骤"></a>4.使用步骤</h2><p>1.需要4个角色,被适配者,适配者,目标接口,目标接口的实现类(这个实现类可以有也可以没有,看具体业务)</p>
<p>2.目的就是让适配者通过他的一顿操作,达到融合被适配者和目标接口到一个类中</p>
<h2 id="5-举个栗子-2"><a href="#5-举个栗子-2" class="headerlink" title="5.举个栗子"></a>5.举个栗子</h2><p>我们用具体的代码去更好的理解这个设计模式</p>
<h4 id="5-1栗子说明-2"><a href="#5-1栗子说明-2" class="headerlink" title="5.1栗子说明"></a>5.1栗子说明</h4><ul>
<li>背景:把220V的电压通过手机充电器转换成5V的电压给手机进行充电</li>
<li>目的:通过适配器模式去进行一个转换</li>
</ul>
<h4 id="5-2使用步骤-2"><a href="#5-2使用步骤-2" class="headerlink" title="5.2使用步骤"></a>5.2使用步骤</h4><p>实现代码如下:</p>
<p><strong>步骤1.</strong>创建被适配者(220V的电压类)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AC220 &#123;</span><br><span class="line">    public int outputAC220V()&#123;</span><br><span class="line">        int output = 220;</span><br><span class="line">        System.out.println(&quot;输出交流电&quot;+output+&quot;V&quot;);</span><br><span class="line">        return output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤2.</strong>创建目标接口(DC5)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface DC5 &#123;</span><br><span class="line">    int outputDC5V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤3.</strong>创建适配器(PowerAdapter)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class PowerAdapter implements DC5 &#123;</span><br><span class="line"></span><br><span class="line">    private AC220 ac220=new AC220();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int outputDC5V() &#123;</span><br><span class="line">        int adapterInput = ac220.outputAC220V();</span><br><span class="line"></span><br><span class="line">        //模拟变压器</span><br><span class="line">        int adapterOutput = adapterInput/44;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;使用PowerAdapter输入AC:&quot;+adapterInput+&quot;V&quot;+&quot;输出DC:&quot;+adapterOutput+&quot;V&quot;);</span><br><span class="line">        return adapterOutput;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤4.</strong> 测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       DC5 dc5 = new PowerAdapter();</span><br><span class="line">       dc5.outputDC5V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-优点-2"><a href="#6-优点-2" class="headerlink" title="6.优点"></a>6.优点</h2><ul>
<li>能提高类的透明性和复用,现有的类复用但不需要改变</li>
<li>目标类和适配器类解耦,提高程序扩展性</li>
<li>符合开闭原则</li>
</ul>
<h2 id="7-缺点-2"><a href="#7-缺点-2" class="headerlink" title="7.缺点"></a>7.缺点</h2><ul>
<li>适配器编写过程要全面考虑,可能会增加系统的复杂性</li>
<li>增加系统代码可读的难度</li>
</ul>
<p></p><h1 align="center">设计模式（十）– 享元模式</h1><p></p>
<p><hr></p>
<blockquote>
<p>源代码<br><a href="https://github.com/hydznsqk/MyDesignPattern" target="_blank" rel="noopener">GitHub源代码</a></p>
</blockquote>
<h2 id="1-本文目标-3"><a href="#1-本文目标-3" class="headerlink" title="1.本文目标"></a>1.本文目标</h2><p>本文目标是为了让大家认识并理解享元模式</p>
<h2 id="2-基本套路-3"><a href="#2-基本套路-3" class="headerlink" title="2.基本套路"></a>2.基本套路</h2><p>定义:提供了减少对象数量从而改善应用所需的对象结构的方式</p>
<p>类型:结构型</p>
<p>选择关键点:被共享的对象是否可以将外部状态提取出来</p>
<p>设计原则:无</p>
<p>使用概率:90%</p>
<p>难度系数:中</p>
<h2 id="3-适用场景-3"><a href="#3-适用场景-3" class="headerlink" title="3.适用场景"></a>3.适用场景</h2><p>1.常常应用于系统底层的开发,以便解决系统的性能问题</p>
<p>2.系统有大量相似对象,需要缓冲池的场景</p>
<h2 id="4-使用步骤-3"><a href="#4-使用步骤-3" class="headerlink" title="4.使用步骤"></a>4.使用步骤</h2><p>用具体的栗子可以更好的理解,继续往下看</p>
<h2 id="5-举个栗子-3"><a href="#5-举个栗子-3" class="headerlink" title="5.举个栗子"></a>5.举个栗子</h2><p>我们用具体的代码去更好的理解这个设计模式</p>
<h4 id="5-1栗子说明-3"><a href="#5-1栗子说明-3" class="headerlink" title="5.1栗子说明"></a>5.1栗子说明</h4><ul>
<li>背景:年底了,各个部门经理需要做报告</li>
<li>目的:用享元模式去进行设计代码</li>
</ul>
<h4 id="5-2使用步骤-3"><a href="#5-2使用步骤-3" class="headerlink" title="5.2使用步骤"></a>5.2使用步骤</h4><p>实现代码如下:</p>
<p><strong>步骤1.</strong>创建员工接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Employee &#123;</span><br><span class="line">    void report();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤2.</strong>创建部门经理,经理本身也属于员工</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Manager implements Employee &#123;</span><br><span class="line"></span><br><span class="line">    private String department;//所属部门</span><br><span class="line">    private String reportContent;//报告内容</span><br><span class="line"></span><br><span class="line">    public Manager(String department) &#123;</span><br><span class="line">        this.department = department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void report() &#123;</span><br><span class="line">        System.out.println(reportContent);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 设置报告内容</span><br><span class="line">     */</span><br><span class="line">    public void setReportContent(String reportContent) &#123;</span><br><span class="line">        this.reportContent = reportContent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤3.</strong>创建员工工厂,精髓就在这一步,如果没有对象就创建,有的话就存储到Map集合中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class EmployeeFactory &#123;</span><br><span class="line">    private static final Map&lt;String,Employee&gt; EMPLOYEE_MAP = new HashMap&lt;&gt;();</span><br><span class="line">    /**</span><br><span class="line">     * 根据部门去获取部门经理</span><br><span class="line">     */</span><br><span class="line">    public static Employee getManager(String department)&#123;</span><br><span class="line">        Manager manager = (Manager) EMPLOYEE_MAP.get(department);</span><br><span class="line"></span><br><span class="line">        if(manager == null)&#123;</span><br><span class="line">            manager = new Manager(department);</span><br><span class="line">            System.out.print(&quot;创建部门经理:&quot;+department);</span><br><span class="line"></span><br><span class="line">            String reportContent = department+&quot;部门汇报:此次报告的主要内容是......&quot;;</span><br><span class="line">            manager.setReportContent(reportContent);</span><br><span class="line">            System.out.println(&quot; 创建报告:&quot;+reportContent);</span><br><span class="line"></span><br><span class="line">            //存到map集合中</span><br><span class="line">            EMPLOYEE_MAP.put(department,manager);</span><br><span class="line">        &#125;</span><br><span class="line">        return manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤4.</strong> 测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">           String department = departments[(int) (Math.random() * departments.length)];</span><br><span class="line">           Manager manager = (Manager) EmployeeFactory.getManager(department);</span><br><span class="line">           manager.report();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-优点-3"><a href="#6-优点-3" class="headerlink" title="6.优点"></a>6.优点</h2><ul>
<li>减少对象的创建,降低内存中对象的数量,降低系统的内存,提高效率</li>
<li>减少内存之外的其他资源占用</li>
</ul>
<h2 id="7-缺点-3"><a href="#7-缺点-3" class="headerlink" title="7.缺点"></a>7.缺点</h2><ul>
<li>关注内/外部状态,关注线程安全问题</li>
<li>使系统,程序的逻辑复杂化</li>
</ul>
<p></p><h1 align="center">设计模式（十一）– 组合模式</h1><p></p>
<p><hr></p>
<blockquote>
<p>源代码<br><a href="https://github.com/hydznsqk/MyDesignPattern" target="_blank" rel="noopener">GitHub源代码</a></p>
</blockquote>
<h2 id="1-本文目标-4"><a href="#1-本文目标-4" class="headerlink" title="1.本文目标"></a>1.本文目标</h2><p>本文目标是为了让大家认识并理解组合模式</p>
<h2 id="2-基本套路-4"><a href="#2-基本套路-4" class="headerlink" title="2.基本套路"></a>2.基本套路</h2><p>定义:将对象组合成树形结构以表示【部分-整体】的层次结构</p>
<p>类型:结构型</p>
<p>选择关键点:被共享的对象是否可以将外部状态提取出来</p>
<p>设计原则:无</p>
<p>使用概率:90%</p>
<p>难度系数:中</p>
<h2 id="3-适用场景-4"><a href="#3-适用场景-4" class="headerlink" title="3.适用场景"></a>3.适用场景</h2><p>1.希望客户端可以忽略组合对象与单个对象的差异时</p>
<p>2.处理一个树形结构时</p>
<h2 id="4-使用步骤-4"><a href="#4-使用步骤-4" class="headerlink" title="4.使用步骤"></a>4.使用步骤</h2><p>用具体的栗子可以更好的理解,继续往下看</p>
<h2 id="5-举个栗子-4"><a href="#5-举个栗子-4" class="headerlink" title="5.举个栗子"></a>5.举个栗子</h2><p>我们用具体的代码去更好的理解这个设计模式</p>
<h4 id="5-1栗子说明-4"><a href="#5-1栗子说明-4" class="headerlink" title="5.1栗子说明"></a>5.1栗子说明</h4><ul>
<li>背景:有很多课程,然后也有很多目录,需要把这些课程进行树桩结构分类</li>
<li>目的:用组合模式去进行这些课程和目录的实现</li>
</ul>
<h4 id="5-2使用步骤-4"><a href="#5-2使用步骤-4" class="headerlink" title="5.2使用步骤"></a>5.2使用步骤</h4><p>实现代码如下:</p>
<p><strong>步骤1.</strong>创建目录抽象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CatalogComponent &#123;</span><br><span class="line">    public void add(CatalogComponent catalogComponent) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持添加操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove(CatalogComponent catalogComponent) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持删除操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName(CatalogComponent catalogComponent) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持获取名称操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice(CatalogComponent catalogComponent) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持获取价格操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持打印操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤2.</strong>创建课程,继承于目录抽象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Course extends CatalogComponent &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private double price;</span><br><span class="line"></span><br><span class="line">    public Course(String name, double price) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName(CatalogComponent catalogComponent) &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double getPrice(CatalogComponent catalogComponent) &#123;</span><br><span class="line">        return this.price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;Course Name:&quot; + name + &quot; Price:&quot; + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤3.</strong>创建目录,继承于目录抽象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class CourseCatalog extends CatalogComponent &#123;</span><br><span class="line">    private List&lt;CatalogComponent&gt; items = new ArrayList&lt;&gt;();</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer level;</span><br><span class="line"></span><br><span class="line">    public CourseCatalog(String name, Integer level) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(CatalogComponent catalogComponent) &#123;</span><br><span class="line">        items.add(catalogComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName(CatalogComponent catalogComponent) &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(CatalogComponent catalogComponent) &#123;</span><br><span class="line">        items.remove(catalogComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(this.name);</span><br><span class="line">        for (CatalogComponent catalogComponent : items) &#123;</span><br><span class="line">            if (this.level != null) &#123;</span><br><span class="line">                for (int i = 0; i &lt; this.level; i++) &#123;</span><br><span class="line">                    System.out.print(&quot;  &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catalogComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤4.</strong> 测试,1级目录是课程主目录,2级目录分别是Java课程目录,操作系统课程目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       //二级目录</span><br><span class="line">       CatalogComponent operatingSystem = new CourseCatalog(&quot;操作系统课程目录&quot;,2);</span><br><span class="line">       CatalogComponent linuxCourse = new Course(&quot;Linux课程&quot;,100);</span><br><span class="line">       CatalogComponent windowsCourse = new Course(&quot;Windows课程&quot;,120);</span><br><span class="line">       operatingSystem.add(linuxCourse);</span><br><span class="line">       operatingSystem.add(windowsCourse);</span><br><span class="line"></span><br><span class="line">       //二级目录</span><br><span class="line">       CatalogComponent javaCourseCatalog = new CourseCatalog(&quot;Java课程目录&quot;,2);</span><br><span class="line">       CatalogComponent javaBase = new Course(&quot;Java基础&quot;,66);</span><br><span class="line">       CatalogComponent designPattern = new Course(&quot;Java设计模式&quot;,77);</span><br><span class="line">       javaCourseCatalog.add(javaBase);</span><br><span class="line">       javaCourseCatalog.add(designPattern);</span><br><span class="line"></span><br><span class="line">       //一级目录(主目录)</span><br><span class="line">       CatalogComponent mainCourseCatalog = new CourseCatalog(&quot;课程主目录&quot;,1);</span><br><span class="line">       mainCourseCatalog.add(linuxCourse);</span><br><span class="line">       mainCourseCatalog.add(windowsCourse);</span><br><span class="line">       mainCourseCatalog.add(javaCourseCatalog);</span><br><span class="line">       mainCourseCatalog.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-优点-4"><a href="#6-优点-4" class="headerlink" title="6.优点"></a>6.优点</h2><ul>
<li>清楚的定义分层次的复杂对象,表示对象的全部或部分层次</li>
<li>让客户端忽略了层次的差异,方便对整个层次结构进行控制</li>
<li>简化客户端的代码</li>
<li>符合开闭原则</li>
</ul>
<h2 id="7-缺点-4"><a href="#7-缺点-4" class="headerlink" title="7.缺点"></a>7.缺点</h2><ul>
<li>限制类型时会较为复杂</li>
<li>使设计变的更加抽象</li>
</ul>
<p></p><h1 align="center">设计模式（十二）– 桥接模式</h1><p></p>
<hr>

<blockquote>
<p>源代码<br><a href="https://github.com/hydznsqk/MyDesignPattern" target="_blank" rel="noopener">GitHub源代码</a></p>
</blockquote>
<h2 id="1-本文目标-5"><a href="#1-本文目标-5" class="headerlink" title="1.本文目标"></a>1.本文目标</h2><p>本文目标是为了让大家认识并理解桥接模式</p>
<h2 id="2-基本套路-5"><a href="#2-基本套路-5" class="headerlink" title="2.基本套路"></a>2.基本套路</h2><p>定义:将抽象部分与它的具体实现部分分离,使它们都可以独立地变换</p>
<p>类型:结构型</p>
<p>选择关键点:是否可以将对象拆分成多个不相关的维度</p>
<p>设计原则:遵循单一职责、迪米特、开闭原则，体现功能复用</p>
<p>使用概率:20%</p>
<p>难度系数:中高</p>
<h2 id="3-适用场景-5"><a href="#3-适用场景-5" class="headerlink" title="3.适用场景"></a>3.适用场景</h2><p>1.抽象和具体之间增加更多的灵活性</p>
<p>2.一个类存在两个(或多个)独立变化的维度,且这两个(或多个)维度都需要独立进行扩展</p>
<p>3.不希望使用继承,或因为多层继承导致系统类的个数剧增</p>
<h2 id="4-使用步骤-5"><a href="#4-使用步骤-5" class="headerlink" title="4.使用步骤"></a>4.使用步骤</h2><p>用具体的栗子可以更好的理解,继续往下看</p>
<h2 id="5-举个栗子-5"><a href="#5-举个栗子-5" class="headerlink" title="5.举个栗子"></a>5.举个栗子</h2><p>我们用具体的代码去更好的理解这个设计模式</p>
<h4 id="5-1栗子说明-5"><a href="#5-1栗子说明-5" class="headerlink" title="5.1栗子说明"></a>5.1栗子说明</h4><ul>
<li>背景:中国有很多银行,有农业银行和工商银行,有自己的账号,然后分为定期和活期,我们想一下,一块是银行,一块是账号</li>
<li>目的:以后银行会越来越多,希望用桥接模式去进行设计,便于扩展</li>
</ul>
<h4 id="5-2使用步骤-5"><a href="#5-2使用步骤-5" class="headerlink" title="5.2使用步骤"></a>5.2使用步骤</h4><p>实现代码如下:</p>
<p><strong>步骤1.</strong>创建银行账号接口类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Account &#123;</span><br><span class="line">    //打开账号</span><br><span class="line">    Account openAccount();</span><br><span class="line"></span><br><span class="line">    //查看账号的类型(是活期还是定期)</span><br><span class="line">    void showAccountType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤2.</strong> 创建定期账号和活期账号,实现于Account接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//定期账号</span><br><span class="line">public class DepositAccount implements Account &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Account openAccount() &#123;</span><br><span class="line">        System.out.println(&quot;打开定期账号&quot;);</span><br><span class="line">        return new DepositAccount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void showAccountType() &#123;</span><br><span class="line">        System.out.println(&quot;这是一个定期账号&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//活期账号</span><br><span class="line">public class SavingAccount implements Account &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Account openAccount() &#123;</span><br><span class="line">        System.out.println(&quot;打开活期账号&quot;);</span><br><span class="line">        //...</span><br><span class="line">        return new SavingAccount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void showAccountType() &#123;</span><br><span class="line">        System.out.println(&quot;这是一个活期账号&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤3.</strong>创建银行抽象类,桥在这个类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Bank &#123;</span><br><span class="line">    //通过组合的方式建立两个类的连线,桥在这里</span><br><span class="line">    protected Account account;</span><br><span class="line">    public Bank(Account account) &#123;</span><br><span class="line">        this.account = account;</span><br><span class="line">    &#125;</span><br><span class="line">    abstract Account openAccount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤4.</strong>创建中国工商银行和中国农业银行,继承于Bank</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//工商银行</span><br><span class="line">public class ICBCBank extends Bank &#123;</span><br><span class="line">    public ICBCBank(Account account) &#123;</span><br><span class="line">        super(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Account openAccount() &#123;</span><br><span class="line">        System.out.println(&quot;打开中国工商银行账号&quot;);</span><br><span class="line">        account.openAccount();</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//农业银行</span><br><span class="line">public class ABCBank extends Bank &#123;</span><br><span class="line">    public ABCBank(Account account) &#123;</span><br><span class="line">        super(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Account openAccount() &#123;</span><br><span class="line">        System.out.println(&quot;打开中国农业银行账号&quot;);</span><br><span class="line">        account.openAccount();</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤5.</strong> 测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       //工商银行,然后账号类型是 定期</span><br><span class="line">       Bank icbcBank = new ICBCBank(new DepositAccount());</span><br><span class="line">       Account icbcAccount = icbcBank.openAccount();</span><br><span class="line">       icbcAccount.showAccountType();</span><br><span class="line"></span><br><span class="line">       //工商银行,然后账号类型是 活期</span><br><span class="line">       Bank icbcBank2 = new ICBCBank(new SavingAccount());</span><br><span class="line">       Account icbcAccount2 = icbcBank2.openAccount();</span><br><span class="line">       icbcAccount2.showAccountType();</span><br><span class="line"></span><br><span class="line">       //农业银行,然后账号类型是 活期</span><br><span class="line">       Bank abcBank = new ABCBank(new SavingAccount());</span><br><span class="line">       Account abcAccount = abcBank.openAccount();</span><br><span class="line">       abcAccount.showAccountType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-优点-5"><a href="#6-优点-5" class="headerlink" title="6.优点"></a>6.优点</h2><ul>
<li>分离抽象部分和具体实现部分</li>
<li>提高了系统的可扩展性</li>
<li>符合开闭原则</li>
<li>符合合成复用原则</li>
</ul>
<h2 id="7-缺点-5"><a href="#7-缺点-5" class="headerlink" title="7.缺点"></a>7.缺点</h2><ul>
<li>增加了系统的理解和设计难度</li>
<li>需要正确的识别出系统中两个独立变化的维度</li>
</ul>
<p></p><h1 align="center">设计模式（十三）– 代理模式</h1><p></p>
<p><hr></p>
<blockquote>
<p>源代码<br><a href="https://github.com/hydznsqk/MyDesignPattern" target="_blank" rel="noopener">GitHub源代码</a></p>
</blockquote>
<h2 id="1-本文目标-6"><a href="#1-本文目标-6" class="headerlink" title="1.本文目标"></a>1.本文目标</h2><p>本文目标是为了让大家认识并理解代理模式</p>
<h2 id="2-基本套路-6"><a href="#2-基本套路-6" class="headerlink" title="2.基本套路"></a>2.基本套路</h2><p>定义:为其他对象提供一种代理,以控制对这个对象的访问</p>
<p>类型:结构型</p>
<p>选择关键点:静态代理选择的关键点是是否要复用被代理的部分功能，动态代理选择的关键点在于能否在将被代理的这一批类当中，找出相同的切入点</p>
<p>设计原则:体现功能复用</p>
<p>使用概率:99.99999%</p>
<p>难度系数:中高</p>
<h2 id="3-适用场景-6"><a href="#3-适用场景-6" class="headerlink" title="3.适用场景"></a>3.适用场景</h2><p>1.保护目标对象</p>
<p>2.增强目标对象</p>
<h2 id="4-使用步骤-6"><a href="#4-使用步骤-6" class="headerlink" title="4.使用步骤"></a>4.使用步骤</h2><p>1.代理模式有委托方和代理方</p>
<p>2.委托方定义接口和使用接口中的方法</p>
<p>3.代理方把代理对象传给委托方并实现委托方的接口,从而实现代理模式</p>
<h2 id="5-举个栗子-6"><a href="#5-举个栗子-6" class="headerlink" title="5.举个栗子"></a>5.举个栗子</h2><p>我们用具体的代码去更好的理解这个设计模式</p>
<h4 id="5-1栗子说明-6"><a href="#5-1栗子说明-6" class="headerlink" title="5.1栗子说明"></a>5.1栗子说明</h4><ul>
<li>背景:现在有一个 添加页面,联系人页面,当在添加页面中添加数据的时候,要把数据传递到联系人页面显示</li>
<li>目的:通过代理模式实现传递数据</li>
</ul>
<h4 id="5-2使用步骤-6"><a href="#5-2使用步骤-6" class="headerlink" title="5.2使用步骤"></a>5.2使用步骤</h4><p>实现代码如下:</p>
<p><strong>步骤1.</strong>创建委托方要定义接口(就是DataInterface)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface DataInterface &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 添加数据的方法</span><br><span class="line">     */</span><br><span class="line">    void  addData(AddController controller, String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤2.</strong>创建委托方,委托方使用接口中的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AddController &#123;</span><br><span class="line">    //定义接口</span><br><span class="line">    public DataInterface mDataInterface;</span><br><span class="line">    public void  addEvent()&#123;</span><br><span class="line">        //使用接口中的方法</span><br><span class="line">        mDataInterface.addData(this,&quot;黄晓明&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤3.</strong>创建代理方,实现接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ContactController implements  DataInterface&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addData(AddController page, String name) &#123;</span><br><span class="line">        System.out.println(&quot;ContactController 添加数据成功 &quot;+page.toString()+ &quot;  名字:&quot;+ name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤4.</strong> 测试,代理方把代理对象传给委托方并实现委托方的接口,从而实现代理模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       AddController addController = new AddController();</span><br><span class="line">       ContactController contactController = new ContactController();</span><br><span class="line"></span><br><span class="line">       //代理方把代理对象传给委托方</span><br><span class="line">       addController.mDataInterface = contactController;</span><br><span class="line">       addController.addEvent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-优点-6"><a href="#6-优点-6" class="headerlink" title="6.优点"></a>6.优点</h2><ul>
<li>代理模式能将代理对象与真实被调用的目标对象分离</li>
<li>一定程度上降低了系统的耦合度,扩展性好</li>
<li>保护目标对象</li>
<li>增强目标对象</li>
</ul>
<h2 id="7-缺点-6"><a href="#7-缺点-6" class="headerlink" title="7.缺点"></a>7.缺点</h2><ul>
<li>代理模式会早场系统设计中类的数目增加</li>
<li>在客户端和目标对象增加一个代理对象,会造成请求处理速度变慢</li>
<li>增加系统的复杂度</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文只是对所有结构型模式的分享,接下来会继续分享行为型模式,大家可以持续进行关注,<a href="https://www.jianshu.com/u/f07649312c75" target="_blank" rel="noopener">信仰年輕的设计模式</a>,蟹蟹啦。</p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/设计模式/" class="post__tag__link">设计模式</a></li><li class="post__tag__item"><a href="/tags/工厂模式/" class="post__tag__link">工厂模式</a></li><li class="post__tag__item"><a href="/tags/Java/" class="post__tag__link">Java</a></li></ul></footer></article><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript></div></div></main><footer class="foot"><div class="foot-copy u-fl"><span>©2018 </span><a href="https://github.com/zhufaner">Tech Team of Zhufaner Inc.</a></div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><a title="Next" href="/2018/12/03/设计模式系列（一）-- 创建型设计模式/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})(document,"script","zhu-fan-er-ji-zhu-tuan-dui","embed");
</script><div style="display: none;"><script src="https://s4.cnzz.com/z_stat.php?id=1261929418&web_id=1261929418" language="JavaScript"></script></div><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>